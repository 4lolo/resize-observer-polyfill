{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ResizeObserver.js","webpack:///webpack/bootstrap 57ba7739e17fe2d4749c","webpack:///./index.js","webpack:///./src/ResizeObserver.js","webpack:///./src/shims/es6-collections.js","webpack:///./src/ResizeObserverController.js","webpack:///./src/shims/performance.now.js","webpack:///./src/shims/requestAnimationFrame.js","webpack:///./src/_ResizeObserver.js","webpack:///./src/ResizeObservation.js","webpack:///./src/ResizeObserverEntry.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_ResizeObserver","_ResizeObserver2","ResizeObserver","window","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_es6Collections","_ResizeObserverController","_ResizeObserverController2","_ResizeObserver3","controller","observers","WeakMap","callback","arguments","observer","set","get","idleTimeout","value","continuousUpdates","forEach","method","_observers$get","apply","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","hasNativeCollections","Map","getIndex","arr","result","some","entry","index","matches","_class","__entries__","push","entries","splice","has","_WeakMap","_class2","clear","slice","keys","map","values","ctx","undefined","_iterator","_isArray","Array","isArray","_i","_ref","next","done","debounce","delay","timeoutID","_this","_len","args","_key","clearTimeout","setTimeout","_performance","_performance2","_requestAnimationFrame","_requestAnimationFrame2","mutationsSupported","MutationObserver","ResizeObserverController","_idleTimeout","_isCycleContinuous","_cycleStartTime","_isCycleActive","_isUpdateScheduled","_listenersEnabled","_mutationsObserver","_observers","runUpdates","bind","_onMutation","_resolveScheduled","_continuousCycleHandler","connect","isConnected","_addListeners","disconnect","indexOf","_removeListeners","_updateObservers","hasChanges","gatherActive","hasActive","broadcastActive","scheduleUpdate","_hasRemainingTime","_endUpdates","timePassed","addEventListener","observe","document","attributes","childList","characterData","subtree","removeEventListener","attrsChanged","type","enable","performance","now","Date","requestAnimationFrame","_ResizeObservation","_ResizeObservation2","_ResizeObserverEntry","_ResizeObserverEntry2","publicObserver","_callback","_targets","_activeTargets","_controller","_publicObserver","Element","targets","unobserve","size","clearActive","observation","broadcastRect","activeTargets","isActive","getStyles","getComputedStyle","pixelsToNumber","parseFloat","getBordersSize","styles","positions","reduce","pos","getPaddings","boxKeys","paddings","createContentRect","width","height","top","left","right","bottom","getSVGContentRect","bbox","getBBox","getDocElementRect","documentElement","getHTMLElementContentRect","clientWidth","clientHeight","emptyRect","horizPad","vertPad","boxSizing","Math","round","vertScrollbar","horizScrollbar","abs","isSVGElement","SVGElement","isDocumentElement","getContentRect","ResizeObservation","_contentRect","broadcastWidth","broadcastHeight","rect","ResizeObserverEntry","rectData","rectInterface","ClientRect","contentRect"],"mappings":"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","file":"ResizeObserver.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ResizeObserver\"] = factory();\n\telse\n\t\troot[\"ResizeObserver\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ResizeObserver\"] = factory();\n\telse\n\t\troot[\"ResizeObserver\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _ResizeObserver = __webpack_require__(1);\n\t\n\tvar _ResizeObserver2 = _interopRequireDefault(_ResizeObserver);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar ResizeObserver = _ResizeObserver2.default;\n\t\n\t// Export existing implementation if it's available.\n\tif (typeof window.ResizeObserver === 'function') {\n\t    ResizeObserver = window.ResizeObserver;\n\t}\n\t\n\texports.default = ResizeObserver;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _es6Collections = __webpack_require__(2);\n\t\n\tvar _ResizeObserverController = __webpack_require__(3);\n\t\n\tvar _ResizeObserverController2 = _interopRequireDefault(_ResizeObserverController);\n\t\n\tvar _ResizeObserver2 = __webpack_require__(6);\n\t\n\tvar _ResizeObserver3 = _interopRequireDefault(_ResizeObserver2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// Controller which will be assigned to all instances of ResizeObserver.\n\tvar controller = new _ResizeObserverController2.default();\n\t\n\t// Registry of internal observers.\n\tvar observers = new _es6Collections.WeakMap();\n\t\n\t/**\r\n\t * ResizeObservers' \"Proxy\" class which is meant to hide private\r\n\t * properties and methods from public instances.\r\n\t *\r\n\t * Additionally it implements \"idleTimeout\" and \"continuousUpdates\" static property\r\n\t * accessors to give a control over the behavior of ResizeObserverController\r\n\t * instance. Changes made to these properties will affect all future and\r\n\t * existing observers.\r\n\t */\n\t\n\tvar ResizeObserver = function () {\n\t    /**\r\n\t     * Creates a new instance of ResizeObserver.\r\n\t     *\r\n\t     * @param {Function} callback - Callback which will\r\n\t     *      be invoked when dimensions of one of the\r\n\t     *      observed elements have been changed.\r\n\t     */\n\t    function ResizeObserver(callback) {\n\t        _classCallCheck(this, ResizeObserver);\n\t\n\t        if (!arguments.length) {\n\t            throw new TypeError('1 argument required, but only 0 present.');\n\t        }\n\t\n\t        var observer = new _ResizeObserver3.default(callback, controller, this);\n\t\n\t        // Register an internal observer.\n\t        observers.set(this, observer);\n\t    }\n\t\n\t    /**\r\n\t     * Extracts controllers' idle timeout value.\r\n\t     *\r\n\t     * @returns {Number}\r\n\t     */\n\t\n\t\n\t    _createClass(ResizeObserver, null, [{\n\t        key: 'idleTimeout',\n\t        get: function get() {\n\t            return controller.idleTimeout;\n\t        }\n\t\n\t        /**\r\n\t         * Sets up new idle timeout.\r\n\t         *\r\n\t         * @param {Number} value - New timeout value.\r\n\t         */\n\t        ,\n\t        set: function set(value) {\n\t            if (typeof value !== 'number') {\n\t                throw new TypeError('type of \"idleTimeout\" value must be a number.');\n\t            }\n\t\n\t            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) < 0) {\n\t                throw new TypeError('\"idleTimeout\" value must be greater than 0.');\n\t            }\n\t\n\t            controller.idleTimeout = value;\n\t        }\n\t\n\t        /**\r\n\t         * Tells whether continuous updates are enabled.\r\n\t         *\r\n\t         * @returns {Boolean}\r\n\t         */\n\t\n\t    }, {\n\t        key: 'continuousUpdates',\n\t        get: function get() {\n\t            return controller.continuousUpdates;\n\t        }\n\t\n\t        /**\r\n\t         * Enables or disables continuous updates.\r\n\t         *\r\n\t         * @param {Boolean} value - Whether to enable or disable\r\n\t         *      continuous updates.\r\n\t         */\n\t        ,\n\t        set: function set(value) {\n\t            if (typeof value !== 'boolean') {\n\t                throw new TypeError('type of \"continuousUpdates\" value must be a boolean.');\n\t            }\n\t\n\t            controller.continuousUpdates = value;\n\t        }\n\t    }]);\n\t\n\t    return ResizeObserver;\n\t}();\n\t\n\t// Expose public methods of ResizeObserver.\n\t\n\t\n\t['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n\t    ResizeObserver.prototype[method] = function () {\n\t        var _observers$get;\n\t\n\t        return (_observers$get = observers.get(this))[method].apply(_observers$get, arguments);\n\t    };\n\t});\n\t\n\texports.default = ResizeObserver;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\r\n\t * A collection of shims that provided minimal\r\n\t * support of WeakMap and Map classes.\r\n\t *\r\n\t * These implementations are not meant to be used outside of\r\n\t * ResizeObserver modules as they cover only a limited range\r\n\t * of use cases.\r\n\t */\n\t\n\t/* eslint-disable require-jsdoc */\n\tvar hasNativeCollections = typeof window.WeakMap === 'function' && typeof window.Map === 'function';\n\t\n\tvar WeakMap = function () {\n\t    if (hasNativeCollections) {\n\t        return window.WeakMap;\n\t    }\n\t\n\t    function getIndex(arr, key) {\n\t        var result = -1;\n\t\n\t        arr.some(function (entry, index) {\n\t            var matches = entry[0] === key;\n\t\n\t            if (matches) {\n\t                result = index;\n\t            }\n\t\n\t            return matches;\n\t        });\n\t\n\t        return result;\n\t    }\n\t\n\t    return function () {\n\t        function _class() {\n\t            _classCallCheck(this, _class);\n\t\n\t            this.__entries__ = [];\n\t        }\n\t\n\t        _class.prototype.get = function get(key) {\n\t            var index = getIndex(this.__entries__, key);\n\t\n\t            return this.__entries__[index][1];\n\t        };\n\t\n\t        _class.prototype.set = function set(key, value) {\n\t            var index = getIndex(this.__entries__, key);\n\t\n\t            if (~index) {\n\t                this.__entries__[index][1] = value;\n\t            } else {\n\t                this.__entries__.push([key, value]);\n\t            }\n\t        };\n\t\n\t        _class.prototype.delete = function _delete(key) {\n\t            var entries = this.__entries__,\n\t                index = getIndex(entries, key);\n\t\n\t            if (~index) {\n\t                entries.splice(index, 1);\n\t            }\n\t        };\n\t\n\t        _class.prototype.has = function has(key) {\n\t            return !!~getIndex(this.__entries__, key);\n\t        };\n\t\n\t        return _class;\n\t    }();\n\t}();\n\t\n\tvar Map = function () {\n\t    if (hasNativeCollections) {\n\t        return window.Map;\n\t    }\n\t\n\t    return function (_WeakMap) {\n\t        _inherits(_class2, _WeakMap);\n\t\n\t        function _class2() {\n\t            _classCallCheck(this, _class2);\n\t\n\t            return _possibleConstructorReturn(this, _WeakMap.apply(this, arguments));\n\t        }\n\t\n\t        _class2.prototype.clear = function clear() {\n\t            this.__entries__.splice(0, this.__entries__.length);\n\t        };\n\t\n\t        _class2.prototype.entries = function entries() {\n\t            return this.__entries__.slice();\n\t        };\n\t\n\t        _class2.prototype.keys = function keys() {\n\t            return this.__entries__.map(function (entry) {\n\t                return entry[0];\n\t            });\n\t        };\n\t\n\t        _class2.prototype.values = function values() {\n\t            return this.__entries__.map(function (entry) {\n\t                return entry[1];\n\t            });\n\t        };\n\t\n\t        _class2.prototype.forEach = function forEach(callback) {\n\t            var ctx = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t            for (var _iterator = this.__entries__, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t                var _ref;\n\t\n\t                if (_isArray) {\n\t                    if (_i >= _iterator.length) break;\n\t                    _ref = _iterator[_i++];\n\t                } else {\n\t                    _i = _iterator.next();\n\t                    if (_i.done) break;\n\t                    _ref = _i.value;\n\t                }\n\t\n\t                var entry = _ref;\n\t\n\t                callback.call(ctx, entry[1], entry[0]);\n\t            }\n\t        };\n\t\n\t        _createClass(_class2, [{\n\t            key: 'size',\n\t            get: function get() {\n\t                return this.__entries__.length;\n\t            }\n\t        }]);\n\t\n\t        return _class2;\n\t    }(WeakMap);\n\t}();\n\t\n\texports.Map = Map;\n\texports.WeakMap = WeakMap;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _performance = __webpack_require__(4);\n\t\n\tvar _performance2 = _interopRequireDefault(_performance);\n\t\n\tvar _requestAnimationFrame = __webpack_require__(5);\n\t\n\tvar _requestAnimationFrame2 = _interopRequireDefault(_requestAnimationFrame);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar mutationsSupported = typeof window.MutationObserver === 'function';\n\t\n\t/**\r\n\t * Creates a wrapper function which ensures that\r\n\t * provided callback will be invoked only once\r\n\t * during the specified delay.\r\n\t *\r\n\t * @param {Function} callback - Function to be invoked.\r\n\t * @param {Number} [delay = 0] - Delay after which to invoke callback.\r\n\t * @returns {Function}\r\n\t */\n\tfunction debounce(callback) {\n\t    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\t\n\t    var timeoutID = false;\n\t\n\t    return function () {\n\t        var _this = this;\n\t\n\t        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t            args[_key] = arguments[_key];\n\t        }\n\t\n\t        if (timeoutID !== false) {\n\t            clearTimeout(timeoutID);\n\t        }\n\t\n\t        timeoutID = setTimeout(function () {\n\t            timeoutID = false;\n\t\n\t            /* eslint-disable no-invalid-this */\n\t            callback.apply(_this, args);\n\t\n\t            /* eslint-enable no-invalid-this */\n\t        }, delay);\n\t    };\n\t}\n\t\n\t/**\r\n\t * Controller class which handles updates of ResizeObserver instances.\r\n\t * It's meant to decide when and for how long it's necessary to run updates by listening to the windows\r\n\t * \"resize\" event along with a tracking of DOM mutations (nodes removal, changes of attributes, etc.).\r\n\t *\r\n\t * Transitions and animations are handled by running a repeatable update cycle either until the dimensions\r\n\t * of observed elements are changing or the timeout is reached (default timeout is 50 milliseconds).\r\n\t * Timeout value can be manually increased if transitions have a delay.\r\n\t *\r\n\t * Continuous update cycle will be used automatically in case if MutationObserver is not supported.\r\n\t */\n\t\n\tvar ResizeObserverController = function () {\n\t    /**\r\n\t     * Creates a new instance of ResizeObserverController.\r\n\t     *\r\n\t     * @param {Number} [idleTimeout = 0] - Idle timeout value.\r\n\t     * @param {Boolean} [continuousUpdates = false] - Whether to use a continuous update cycle.\r\n\t     */\n\t    function ResizeObserverController() {\n\t        var idleTimeout = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];\n\t        var continuousUpdates = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t        _classCallCheck(this, ResizeObserverController);\n\t\n\t        this._idleTimeout = idleTimeout;\n\t        this._isCycleContinuous = continuousUpdates;\n\t\n\t        this._cycleStartTime = 0;\n\t\n\t        // Indicates whether the update cycle is currently running.\n\t        this._isCycleActive = false;\n\t\n\t        // Indicates whether the update of observers is scheduled.\n\t        this._isUpdateScheduled = false;\n\t\n\t        // Indicates whether DOM listeners have been added.\n\t        this._listenersEnabled = false;\n\t\n\t        // Keeps reference to the instance of MutationObserver.\n\t        this._mutationsObserver = null;\n\t\n\t        // A list of connected observers.\n\t        this._observers = [];\n\t\n\t        // Fix value of \"this\" binding for the following methods.\n\t        this.runUpdates = this.runUpdates.bind(this);\n\t        this._onMutation = this._onMutation.bind(this);\n\t        this._resolveScheduled = this._resolveScheduled.bind(this);\n\t\n\t        // Function that will be invoked to re-run the\n\t        // update cycle if continuous cycles are enabled.\n\t        this._continuousCycleHandler = debounce(this.runUpdates, 100);\n\t    }\n\t\n\t    /**\r\n\t     * Returns current idle timeout value.\r\n\t     *\r\n\t     * @returns {Number}\r\n\t     */\n\t\n\t\n\t    /**\r\n\t     * Adds observer to observers list.\r\n\t     *\r\n\t     * @param {ResizeObserver} observer - Observer to be added.\r\n\t     */\n\t    ResizeObserverController.prototype.connect = function connect(observer) {\n\t        if (!this.isConnected(observer)) {\n\t            this._observers.push(observer);\n\t        }\n\t\n\t        // Add listeners if they haven't been added yet.\n\t        if (!this._listenersEnabled) {\n\t            this._addListeners();\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * Removes observer from observers list.\r\n\t     *\r\n\t     * @param {ResizeObserver} observer - Observer to be removed.\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype.disconnect = function disconnect(observer) {\n\t        var observers = this._observers,\n\t            index = observers.indexOf(observer);\n\t\n\t        if (~index) {\n\t            observers.splice(index, 1);\n\t        }\n\t\n\t        // Remove listeners if controller\n\t        // has no connected observers.\n\t        if (!observers.length && this._listenersEnabled) {\n\t            this._removeListeners();\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * Tells whether provided observer is connected to controller.\r\n\t     *\r\n\t     * @param {ResizeObserver} observer - Observer to be checked.\r\n\t     * @returns {Boolean}\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype.isConnected = function isConnected(observer) {\n\t        return !!~this._observers.indexOf(observer);\n\t    };\n\t\n\t    /**\r\n\t     * Updates every observer from observers list and\r\n\t     * notifies them of queued entries.\r\n\t     *\r\n\t     * @private\r\n\t     * @returns {Boolean} Returns \"true\" if any observer\r\n\t     *      has detected changes in dimensions of its' elements.\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype._updateObservers = function _updateObservers() {\n\t        var hasChanges = false;\n\t\n\t        for (var _iterator = this._observers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t            var _ref;\n\t\n\t            if (_isArray) {\n\t                if (_i >= _iterator.length) break;\n\t                _ref = _iterator[_i++];\n\t            } else {\n\t                _i = _iterator.next();\n\t                if (_i.done) break;\n\t                _ref = _i.value;\n\t            }\n\t\n\t            var observer = _ref;\n\t\n\t            observer.gatherActive();\n\t\n\t            if (observer.hasActive()) {\n\t                hasChanges = true;\n\t\n\t                observer.broadcastActive();\n\t            }\n\t        }\n\t\n\t        return hasChanges;\n\t    };\n\t\n\t    /**\r\n\t     * Starts the update cycle which will run either\r\n\t     * until it detects changes in the dimensions of\r\n\t     * elements or the idle timeout is reached.\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype.runUpdates = function runUpdates() {\n\t        this._cycleStartTime = (0, _performance2.default)();\n\t        this._isCycleActive = true;\n\t\n\t        this.scheduleUpdate();\n\t    };\n\t\n\t    /**\r\n\t     * Schedules the update of observers.\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype.scheduleUpdate = function scheduleUpdate() {\n\t        // Schedule new update if it\n\t        // hasn't been scheduled already.\n\t        if (!this._isUpdateScheduled) {\n\t            this._isUpdateScheduled = true;\n\t\n\t            (0, _requestAnimationFrame2.default)(this._resolveScheduled);\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * Invokes the update of observers. It may re-run the\r\n\t     * cycle if changes in observers have been detected.\r\n\t     *\r\n\t     * @private\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype._resolveScheduled = function _resolveScheduled() {\n\t        var hasChanges = this._updateObservers();\n\t\n\t        this._isUpdateScheduled = false;\n\t\n\t        // Do nothing if cycle wasn't started,\n\t        // i.e. a single update was requested.\n\t        if (!this._isCycleActive) {\n\t            return;\n\t        }\n\t\n\t        // Re-start cycle so that we can catch future changes,\n\t        // e.g. when there are active CSS transitions.\n\t        if (hasChanges) {\n\t            this.runUpdates();\n\t        } else if (this._hasRemainingTime()) {\n\t            // Keep running updates if idle timeout isn't reached yet.\n\t            // This way we make it possible to adjust to delayed transitions.\n\t            this.scheduleUpdate();\n\t        } else {\n\t            // Finish update cycle.\n\t            this._endUpdates();\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * Tells whether the update cycle has time remaining.\r\n\t     *\r\n\t     * @private\r\n\t     * @returns {Boolean}\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype._hasRemainingTime = function _hasRemainingTime() {\n\t        var timePassed = (0, _performance2.default)() - this._cycleStartTime;\n\t\n\t        return this._idleTimeout - timePassed > 0;\n\t    };\n\t\n\t    /**\r\n\t     * Callback which is invoked when update cycle\r\n\t     * is finished. It may start a new cycle if continuous\r\n\t     * updates are enabled.\r\n\t     *\r\n\t     * @private\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype._endUpdates = function _endUpdates() {\n\t        this._isCycleActive = false;\n\t\n\t        if (this._isCycleContinuous && this._listenersEnabled) {\n\t            this._continuousCycleHandler();\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * Initializes DOM listeners.\r\n\t     *\r\n\t     * @private\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype._addListeners = function _addListeners() {\n\t        // Do nothing if listeners have been already added.\n\t        if (this._listenersEnabled) {\n\t            return;\n\t        }\n\t\n\t        this._listenersEnabled = true;\n\t\n\t        // Repeatable cycle is used here because the resize event may\n\t        // lead to continuous changes, e.g. when width or height of an element\n\t        // are controlled by CSS transitions.\n\t        window.addEventListener('resize', this.runUpdates);\n\t\n\t        // Fall back to an infinite cycle.\n\t        if (!mutationsSupported) {\n\t            this._isCycleContinuous = true;\n\t        } else {\n\t            // Subscribe to DOM mutations as they may lead to\n\t            // changes in dimensions of elements.\n\t            this._mutationsObserver = new MutationObserver(this._onMutation);\n\t\n\t            this._mutationsObserver.observe(document, {\n\t                attributes: true,\n\t                childList: true,\n\t                characterData: true,\n\t                subtree: true\n\t            });\n\t        }\n\t\n\t        // Don't wait for possible event that might trigger the\n\t        // update of observers and manually initiate update cycle.\n\t        if (this._isCycleContinuous) {\n\t            this.runUpdates();\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * Removes DOM listeners.\r\n\t     *\r\n\t     * @private\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype._removeListeners = function _removeListeners() {\n\t        // Do nothing if listeners have been already removed.\n\t        if (!this._listenersEnabled) {\n\t            return;\n\t        }\n\t\n\t        window.removeEventListener('resize', this.runUpdates);\n\t\n\t        if (this._mutationsObserver) {\n\t            this._mutationsObserver.disconnect();\n\t        }\n\t\n\t        this._mutationsObserver = null;\n\t        this._listenersEnabled = false;\n\t    };\n\t\n\t    /**\r\n\t     * DOM mutations handler.\r\n\t     *\r\n\t     * @private\r\n\t     * @param {Array<MutationRecord>} entries - An array of mutation records.\r\n\t     */\n\t\n\t\n\t    ResizeObserverController.prototype._onMutation = function _onMutation(entries) {\n\t        // Check if at least one entry\n\t        // contains attributes changes.\n\t        var attrsChanged = entries.some(function (entry) {\n\t            return entry.type === 'attributes';\n\t        });\n\t\n\t        // It's expected that animations may start only\n\t        // after some attribute changes its' value.\n\t        attrsChanged ? this.runUpdates() : this.scheduleUpdate();\n\t    };\n\t\n\t    _createClass(ResizeObserverController, [{\n\t        key: 'idleTimeout',\n\t        get: function get() {\n\t            return this._idleTimeout;\n\t        }\n\t\n\t        /**\r\n\t         * Sets up new idle timeout value.\r\n\t         *\r\n\t         * @param {Number} value - New timeout value.\r\n\t         */\n\t        ,\n\t        set: function set(value) {\n\t            this._idleTimeout = value;\n\t        }\n\t\n\t        /**\r\n\t         * Tells whether continuous updates are enabled.\r\n\t         *\r\n\t         * @returns {Boolean}\r\n\t         */\n\t\n\t    }, {\n\t        key: 'continuousUpdates',\n\t        get: function get() {\n\t            return this._isCycleContinuous;\n\t        }\n\t\n\t        /**\r\n\t         * Enables or disables continuous updates.\r\n\t         *\r\n\t         * @param {Boolean} enable - Whether to enable or disable\r\n\t         *      continuous updates. Note that the value won't be applied\r\n\t         *      if MutationObserver is not supported.\r\n\t         */\n\t        ,\n\t        set: function set(enable) {\n\t            // The state of continuous updates should not be modified\n\t            // if MutationObserver is not supported.\n\t            if (!mutationsSupported) {\n\t                return;\n\t            }\n\t\n\t            this._isCycleContinuous = enable;\n\t\n\t            // Immediately start the update cycle in order not to\n\t            // wait for a possible event that will initiate it.\n\t            if (this._listenersEnabled && enable) {\n\t                this.runUpdates();\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return ResizeObserverController;\n\t}();\n\t\n\texports.default = ResizeObserverController;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\t/**\r\n\t * A shim for performance.now method which falls back\r\n\t * to Date.now if the first one is not supported.\r\n\t *\r\n\t * @returns {Timestamp}\r\n\t */\n\texports.default = function () {\n\t    if (window.performance && typeof window.performance.now === 'function') {\n\t        return function () {\n\t            return window.performance.now();\n\t        };\n\t    }\n\t\n\t    return function () {\n\t        return Date.now();\n\t    };\n\t}();\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\t/**\r\n\t * A shim for requestAnimationFrame which falls back\r\n\t * to setTimeout if the first one is not supported.\r\n\t *\r\n\t * @returns {Number} Requests' identifier.\r\n\t */\n\texports.default = function () {\n\t    if (window.requestAnimationFrame && typeof window.requestAnimationFrame === 'function') {\n\t        return window.requestAnimationFrame;\n\t    }\n\t\n\t    return function (callback) {\n\t        return setTimeout(function () {\n\t            return callback(Date.now());\n\t        }, 1000 / 60);\n\t    };\n\t}();\n\t\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _es6Collections = __webpack_require__(2);\n\t\n\tvar _ResizeObservation = __webpack_require__(7);\n\t\n\tvar _ResizeObservation2 = _interopRequireDefault(_ResizeObservation);\n\t\n\tvar _ResizeObserverEntry = __webpack_require__(8);\n\t\n\tvar _ResizeObserverEntry2 = _interopRequireDefault(_ResizeObserverEntry);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ResizeObserver = function () {\n\t    /**\r\n\t     * Creates a new instance of ResizeObserver.\r\n\t     *\r\n\t     * @param {Function} callback - Callback function which will be invoked\r\n\t     *      when one of the observed elements changes its' content rectangle.\r\n\t     * @param {ResizeObsreverController} controller - Controller instance\r\n\t     *      which is responsible for the updates of observer.\r\n\t     * @param {ResizeObserver} publicObserver - Reference\r\n\t     *      to the public ResizeObserver instance which will be passed\r\n\t     *      to callback function.\r\n\t     */\n\t    function ResizeObserver(callback, controller, publicObserver) {\n\t        _classCallCheck(this, ResizeObserver);\n\t\n\t        if (typeof callback !== 'function') {\n\t            throw new TypeError('The callback provided as parameter 1 is not a function.');\n\t        }\n\t\n\t        // Reference to the callback function.\n\t        this._callback = callback;\n\t\n\t        // A registry of ResizeObservation instances.\n\t        this._targets = new _es6Collections.Map();\n\t\n\t        // A collection of resize observations that have detected\n\t        // changes in dimensions of elements.\n\t        this._activeTargets = [];\n\t\n\t        // Reference to associated ResizeObserverController.\n\t        this._controller = controller;\n\t\n\t        // Public ResizeObserver instance which will be passed\n\t        // to callback function.\n\t        this._publicObserver = publicObserver;\n\t    }\n\t\n\t    /**\r\n\t     * Starts observing provided element.\r\n\t     *\r\n\t     * @param {Element} target - Element to be observed.\r\n\t     */\n\t\n\t\n\t    ResizeObserver.prototype.observe = function observe(target) {\n\t        //  Throw the same errors as in a native implementation.\n\t        if (!arguments.length) {\n\t            throw new TypeError('1 argument required, but only 0 present.');\n\t        }\n\t\n\t        if (!(target instanceof Element)) {\n\t            throw new TypeError('parameter 1 is not of type \"Element\".');\n\t        }\n\t\n\t        var targets = this._targets;\n\t\n\t        // Do nothing if element is already being observed.\n\t        if (targets.has(target)) {\n\t            return;\n\t        }\n\t\n\t        targets.set(target, new _ResizeObservation2.default(target));\n\t\n\t        // Add observer to controller if\n\t        // it hasn't been connected yet.\n\t        if (!this._controller.isConnected(this)) {\n\t            this._controller.connect(this);\n\t        }\n\t\n\t        // Update observations.\n\t        this._controller.runUpdates();\n\t    };\n\t\n\t    /**\r\n\t     * Stops observing provided element.\r\n\t     *\r\n\t     * @param {Element} target - Element to stop observing.\r\n\t     */\n\t\n\t\n\t    ResizeObserver.prototype.unobserve = function unobserve(target) {\n\t        //  Throw the same errors as in a native implementation.\n\t        if (!arguments.length) {\n\t            throw new TypeError('1 argument required, but only 0 present.');\n\t        }\n\t\n\t        if (!(target instanceof Element)) {\n\t            throw new TypeError('parameter 1 is not of type \"Element\".');\n\t        }\n\t\n\t        var targets = this._targets;\n\t\n\t        // Do nothing if element is not being observed.\n\t        if (!targets.has(target)) {\n\t            return;\n\t        }\n\t\n\t        // Remove element and associated with\n\t        // it ResizeObsrvation instance from registry.\n\t        targets.delete(target);\n\t\n\t        // Set back the initial state if\n\t        // there is nothing to observe.\n\t        if (!targets.size) {\n\t            this.disconnect();\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * Stops observing all elements and\r\n\t     * clears the observations list.\r\n\t     */\n\t\n\t\n\t    ResizeObserver.prototype.disconnect = function disconnect() {\n\t        this.clearActive();\n\t        this._targets.clear();\n\t        this._controller.disconnect(this);\n\t    };\n\t\n\t    /**\r\n\t     * Invokes initial callback function with a list\r\n\t     * of ResizeObserverEntry instances collected from\r\n\t     * active resize observations.\r\n\t     */\n\t\n\t\n\t    ResizeObserver.prototype.broadcastActive = function broadcastActive() {\n\t        // Do nothing if observer doesn't\n\t        // have active observations.\n\t        if (!this.hasActive()) {\n\t            return;\n\t        }\n\t\n\t        var publicObserver = this._publicObserver;\n\t\n\t        // Create ResizeObserverEntry instance\n\t        // for every active observation.\n\t        var entries = this._activeTargets.map(function (observation) {\n\t            return new _ResizeObserverEntry2.default(observation.target, observation.broadcastRect());\n\t        });\n\t\n\t        this.clearActive();\n\t\n\t        this._callback.call(publicObserver, entries, publicObserver);\n\t    };\n\t\n\t    /**\r\n\t     * Clears the collection of pending/active observations.\r\n\t     */\n\t\n\t\n\t    ResizeObserver.prototype.clearActive = function clearActive() {\n\t        this._activeTargets.splice(0);\n\t    };\n\t\n\t    /**\r\n\t     * Tells whether the observer has\r\n\t     * pending observations.\r\n\t     *\r\n\t     * @returns {Boolean}\r\n\t     */\n\t\n\t\n\t    ResizeObserver.prototype.hasActive = function hasActive() {\n\t        return !!this._activeTargets.length;\n\t    };\n\t\n\t    /**\r\n\t     * Clears an array of previously collected active observations\r\n\t     * and collects observation instances whose associated element\r\n\t     * has changes in its' content rectangle.\r\n\t     */\n\t\n\t\n\t    ResizeObserver.prototype.gatherActive = function gatherActive() {\n\t        this.clearActive();\n\t\n\t        var activeTargets = this._activeTargets;\n\t\n\t        this._targets.forEach(function (observation) {\n\t            if (observation.isActive()) {\n\t                activeTargets.push(observation);\n\t            }\n\t        });\n\t    };\n\t\n\t    return ResizeObserver;\n\t}();\n\t\n\texports.default = ResizeObserver;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// Placeholder of a content rectangle.\n\tvar emptyRect = createContentRect(0, 0, 0, 0);\n\t\n\t/**\r\n\t * Extracts computed styles of provided element.\r\n\t *\r\n\t * @param {Element} target\r\n\t * @returns {CSSStyleDeclaration}\r\n\t */\n\tfunction getStyles(target) {\n\t    return window.getComputedStyle(target);\n\t}\n\t\n\t/**\r\n\t * Converts provided string defined\r\n\t * in q form of '{{value}}px' to number.\r\n\t *\r\n\t * @param {String} value\r\n\t * @returns {Number}\r\n\t */\n\tfunction pixelsToNumber(value) {\n\t    return parseFloat(value) || 0;\n\t}\n\t\n\t/**\r\n\t * Extracts borders size from provided styles.\r\n\t *\r\n\t * @param {CSSStyleDeclaration} styles\r\n\t * @param {...String} positions - Borders positions (top, right, ...)\r\n\t * @returns {Number}\r\n\t */\n\tfunction getBordersSize(styles) {\n\t    for (var _len = arguments.length, positions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        positions[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    return positions.reduce(function (size, pos) {\n\t        var value = styles['border-' + pos + '-width'];\n\t\n\t        return size + pixelsToNumber(value);\n\t    }, 0);\n\t}\n\t\n\t/**\r\n\t *  Extracts paddings sizes from provided styles.\r\n\t *\r\n\t * @param {CSSStyleDeclaration} styles\r\n\t * @returns {Object} Paddings box.\r\n\t */\n\tfunction getPaddings(styles) {\n\t    var boxKeys = ['top', 'right', 'bottom', 'left'];\n\t    var paddings = {};\n\t\n\t    for (var _iterator = boxKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t        var _ref;\n\t\n\t        if (_isArray) {\n\t            if (_i >= _iterator.length) break;\n\t            _ref = _iterator[_i++];\n\t        } else {\n\t            _i = _iterator.next();\n\t            if (_i.done) break;\n\t            _ref = _i.value;\n\t        }\n\t\n\t        var key = _ref;\n\t\n\t        var value = styles['padding-' + key];\n\t\n\t        paddings[key] = pixelsToNumber(value);\n\t    }\n\t\n\t    return paddings;\n\t}\n\t\n\t/**\r\n\t * Creates content rectangle based on the provided dimensions\r\n\t * and the top/left positions.\r\n\t *\r\n\t * @param {Number} width - Width of rectangle.\r\n\t * @param {Number} height - Height of rectangle.\r\n\t * @param {Number} top - Top position.\r\n\t * @param {Number} left - Left position.\r\n\t * @returns {ClientRect}\r\n\t */\n\tfunction createContentRect(width, height, top, left) {\n\t    return {\n\t        width: width, height: height, top: top,\n\t        right: width + left,\n\t        bottom: height + top,\n\t        left: left\n\t    };\n\t}\n\t\n\t/**\r\n\t * Calculates content rectangle of provided SVG element.\r\n\t *\r\n\t * @param {SVGElement} target - Element whose content\r\n\t *      rectangle needs to be calculated.\r\n\t * @returns {ClientRect}\r\n\t */\n\tfunction getSVGContentRect(target) {\n\t    var bbox = target.getBBox();\n\t\n\t    return createContentRect(bbox.width, bbox.height, 0, 0);\n\t}\n\t\n\t/**\r\n\t * Calculates content rectangle of a root element.\r\n\t *\r\n\t * @returns {ClientRect}\r\n\t */\n\tfunction getDocElementRect() {\n\t    // Neither scroll[Width/Height] nor offset[Width/Height] can be used to define\n\t    // content dimensions as they give inconsistent results across different browser.\n\t    // E.g. in Internet Explorer 10 and lower these properties can't be less than\n\t    // client dimensions (same thing with the \"getBoundingClientRect\" method).\n\t    // And Firefox has the same behavior with its \"scroll\" properties.\n\t    var styles = getStyles(document.documentElement);\n\t\n\t    var width = pixelsToNumber(styles.width);\n\t    var height = pixelsToNumber(styles.height);\n\t\n\t    return createContentRect(width, height, 0, 0);\n\t}\n\t\n\t/**\r\n\t * Calculates content rectangle of provided HTMLElement.\r\n\t *\r\n\t * @param {HTMLElement} target - Element whose content\r\n\t *      rectangle needs to be calculated.\r\n\t * @returns {ClientRect}\r\n\t */\n\tfunction getHTMLElementContentRect(target) {\n\t    // Client width & height properties can't be\n\t    // used exclusively as they provide rounded values.\n\t    var clientWidth = target.clientWidth;\n\t    var clientHeight = target.clientHeight;\n\t\n\t    // By this condition we can catch all non-replaced inline, hidden and detached\n\t    // elements. Though elements whose width & height are less than 0.5 will\n\t    // be discarded as well.\n\t    //\n\t    // Without it we would need to implement separate methods for each of\n\t    // those cases and it's not possible to perform a precise and performance\n\t    // effective test for hidden elements. E.g. even jQuerys' ':visible' filter\n\t    // gives wrong results for elements whose width & height are less\n\t    // than 0.5.\n\t    if (!clientWidth && !clientHeight) {\n\t        return emptyRect;\n\t    }\n\t\n\t    var styles = getStyles(target);\n\t    var paddings = getPaddings(styles);\n\t    var horizPad = paddings.left + paddings.right;\n\t    var vertPad = paddings.top + paddings.bottom;\n\t\n\t    // Computed styles of width & height are being used because they\n\t    // are the only dimensions available to JS that contain non-rounded values. It could\n\t    // have been possible to utilize getBoundingClientRect if only its' data wasn't\n\t    // affected by CSS transformations let alone paddings, borders and scroll bars.\n\t    var width = pixelsToNumber(styles.width),\n\t        height = pixelsToNumber(styles.height);\n\t\n\t    // Width & height include paddings and borders\n\t    // when 'border-box' box model is applied (except for IE).\n\t    if (styles.boxSizing === 'border-box') {\n\t        // Following conditions are required to handle Internet Explorer which\n\t        // doesn't include paddings and borders to computed CSS dimensions.\n\t        //\n\t        // We can say that if CSS dimensions + paddings are equal to the \"client\" properties\n\t        // then it's either IE, and thus we don't need to subtract anything, or\n\t        // an element merely doesn't have paddings/borders styles.\n\t        if (Math.round(width + horizPad) !== clientWidth) {\n\t            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n\t        }\n\t\n\t        if (Math.round(height + vertPad) !== clientHeight) {\n\t            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n\t        }\n\t    }\n\t\n\t    // In some browsers (only in Firefox, actually) CSS width & height\n\t    // include scroll bars size which can be removed at this step as scroll bars\n\t    // are the only difference between rounded dimensions + paddings\n\t    // and \"client\" properties, though that is not always true in Chrome.\n\t    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n\t    var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\t\n\t    // Chrome has a rather weird rounding of \"client\" properties.\n\t    // E.g. for an element whose content width is 314.2px it sometimes\n\t    // gives the client width of 315px and for the width of 314.7px\n\t    // it may give 314px. And it doesn't happen all the time.\n\t    // This kind of difference needs to be ignored.\n\t    if (Math.abs(vertScrollbar) !== 1) {\n\t        width -= vertScrollbar;\n\t    }\n\t\n\t    if (Math.abs(horizScrollbar) !== 1) {\n\t        height -= horizScrollbar;\n\t    }\n\t\n\t    return createContentRect(width, height, paddings.top, paddings.left);\n\t}\n\t\n\t/**\r\n\t * Checks whether provided element\r\n\t * is an instance of SVGElement.\r\n\t *\r\n\t * @param {Element} target - Element to be checked.\r\n\t * @returns {Boolean}\r\n\t */\n\tfunction isSVGElement(target) {\n\t    return target instanceof window.SVGElement;\n\t}\n\t\n\t/**\r\n\t * Checks whether provided element is\r\n\t * a document element (root element of a document).\r\n\t *\r\n\t * @param {Element} target - Element to be checked.\r\n\t * @returns {Boolean}\r\n\t */\n\tfunction isDocumentElement(target) {\n\t    return target === document.documentElement;\n\t}\n\t\n\t/**\r\n\t * Calculates an appropriate content rectangle\r\n\t * for provided html or svg element.\r\n\t *\r\n\t * @param {Element} target - Element whose content rectangle\r\n\t *      needs to be calculated.\r\n\t * @returns {ClientRect}\r\n\t */\n\tfunction getContentRect(target) {\n\t    if (isSVGElement(target)) {\n\t        return getSVGContentRect(target);\n\t    }\n\t\n\t    if (isDocumentElement(target)) {\n\t        return getDocElementRect();\n\t    }\n\t\n\t    return getHTMLElementContentRect(target);\n\t}\n\t\n\t/**\r\n\t * Class that is responsible for computations of the\r\n\t * content rectangle of provided DOM element and\r\n\t * for keeping track of its' changes.\r\n\t */\n\t\n\tvar ResizeObservation = function () {\n\t    /**\r\n\t     * Creates an instance of ResizeObservation.\r\n\t     *\r\n\t     * @param {Element} target - Element whose content\r\n\t     *      rectangle needs to be observed.\r\n\t     */\n\t    function ResizeObservation(target) {\n\t        _classCallCheck(this, ResizeObservation);\n\t\n\t        this.target = target;\n\t\n\t        // Keeps reference to the last observed content rectangle.\n\t        this._contentRect = emptyRect;\n\t\n\t        // Broadcasted width of content rectangle.\n\t        this.broadcastWidth = 0;\n\t\n\t        // Broadcasted height of content rectangle.\n\t        this.broadcastHeight = 0;\n\t    }\n\t\n\t    /**\r\n\t     * Updates 'broadcastWidth' and 'broadcastHeight'\r\n\t     * properties with a data from the corresponding\r\n\t     * properties of the last observed content rectangle.\r\n\t     *\r\n\t     * @returns {ClientRect} Last observed content rectangle.\r\n\t     */\n\t\n\t\n\t    ResizeObservation.prototype.broadcastRect = function broadcastRect() {\n\t        var rect = this._contentRect;\n\t\n\t        this.broadcastWidth = rect.width;\n\t        this.broadcastHeight = rect.height;\n\t\n\t        return rect;\n\t    };\n\t\n\t    /**\r\n\t     * Updates content rectangle and tells whether its'\r\n\t     * width or height properties have changed since\r\n\t     * the last broadcast.\r\n\t     *\r\n\t     * @returns {Boolean}\r\n\t     */\n\t\n\t\n\t    ResizeObservation.prototype.isActive = function isActive() {\n\t        var rect = getContentRect(this.target);\n\t\n\t        this._contentRect = rect;\n\t\n\t        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n\t    };\n\t\n\t    return ResizeObservation;\n\t}();\n\t\n\texports.default = ResizeObservation;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ResizeObserverEntry =\n\t/**\r\n\t * Creates an instance of ResizeObserverEntry.\r\n\t *\r\n\t * @param {Element} target - Element that is being observed.\r\n\t * @param {ClientRect} rectData - Data of the elements' content rectangle.\r\n\t */\n\tfunction ResizeObserverEntry(target, rectData) {\n\t    _classCallCheck(this, ResizeObserverEntry);\n\t\n\t    // Content rectangle needs to be an instance\n\t    // of ClientRect if it's available.\n\t    var rectInterface = window.ClientRect ? ClientRect.prototype : Object.prototype;\n\t\n\t    // According to the specification following properties\n\t    // are not writable and in native implementation\n\t    // they are also not enumerable.\n\t    var contentRect = Object.create(rectInterface, {\n\t        width: { value: rectData.width },\n\t        height: { value: rectData.height },\n\t        top: { value: rectData.top },\n\t        right: { value: rectData.right },\n\t        bottom: { value: rectData.bottom },\n\t        left: { value: rectData.left }\n\t    });\n\t\n\t    Object.defineProperties(this, {\n\t        target: { value: target },\n\t        contentRect: { value: contentRect }\n\t    });\n\t};\n\t\n\texports.default = ResizeObserverEntry;\n\tmodule.exports = exports[\"default\"];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ResizeObserver.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 57ba7739e17fe2d4749c\n **/","import ResizeObserverPolyfill from './src/ResizeObserver';\r\n\r\nlet ResizeObserver = ResizeObserverPolyfill;\r\n\r\n// Export existing implementation if it's available.\r\nif (typeof window.ResizeObserver === 'function') {\r\n    ResizeObserver = window.ResizeObserver;\r\n}\r\n\r\nexport default ResizeObserver;\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","import {WeakMap} from './shims/es6-collections';\r\nimport ResizeObserverController from './ResizeObserverController';\r\nimport _ResizeObserver from './_ResizeObserver';\r\n\r\n// Controller which will be assigned to all instances of ResizeObserver.\r\nconst controller = new ResizeObserverController();\r\n\r\n// Registry of internal observers.\r\nconst observers = new WeakMap();\r\n\r\n/**\r\n * ResizeObservers' \"Proxy\" class which is meant to hide private\r\n * properties and methods from public instances.\r\n *\r\n * Additionally it implements \"idleTimeout\" and \"continuousUpdates\" static property\r\n * accessors to give a control over the behavior of ResizeObserverController\r\n * instance. Changes made to these properties will affect all future and\r\n * existing observers.\r\n */\r\nclass ResizeObserver {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {Function} callback - Callback which will\r\n     *      be invoked when dimensions of one of the\r\n     *      observed elements have been changed.\r\n     */\r\n    constructor(callback) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        const observer = new _ResizeObserver(callback, controller, this);\r\n\r\n        // Register an internal observer.\r\n        observers.set(this, observer);\r\n    }\r\n\r\n    /**\r\n     * Extracts controllers' idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    static get idleTimeout() {\r\n        return controller.idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    static set idleTimeout(value) {\r\n        if (typeof value !== 'number') {\r\n            throw new TypeError('type of \"idleTimeout\" value must be a number.');\r\n        }\r\n\r\n        if (typeof value < 0) {\r\n            throw new TypeError('\"idleTimeout\" value must be greater than 0.');\r\n        }\r\n\r\n        controller.idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Tells whether continuous updates are enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    static get continuousUpdates() {\r\n        return controller.continuousUpdates;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables continuous updates.\r\n     *\r\n     * @param {Boolean} value - Whether to enable or disable\r\n     *      continuous updates.\r\n     */\r\n    static set continuousUpdates(value) {\r\n        if (typeof value !== 'boolean') {\r\n            throw new TypeError('type of \"continuousUpdates\" value must be a boolean.');\r\n        }\r\n\r\n        controller.continuousUpdates = value;\r\n    }\r\n}\r\n\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(method => {\r\n    ResizeObserver.prototype[method] = function () {\r\n        return observers.get(this)[method](...arguments);\r\n    };\r\n});\r\n\r\nexport default ResizeObserver;\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ResizeObserver.js\n **/","/**\r\n * A collection of shims that provided minimal\r\n * support of WeakMap and Map classes.\r\n *\r\n * These implementations are not meant to be used outside of\r\n * ResizeObserver modules as they cover only a limited range\r\n * of use cases.\r\n */\r\n\r\n/* eslint-disable require-jsdoc */\r\nconst hasNativeCollections =\r\n    typeof window.WeakMap === 'function' &&\r\n    typeof window.Map === 'function';\r\n\r\nconst WeakMap = (() => {\r\n    if (hasNativeCollections) {\r\n        return window.WeakMap;\r\n    }\r\n\r\n    function getIndex(arr, key) {\r\n        let result = -1;\r\n\r\n        arr.some((entry, index) => {\r\n            let matches = entry[0] === key;\r\n\r\n            if (matches) {\r\n                result = index;\r\n            }\r\n\r\n            return matches;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return class {\r\n        constructor() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        get(key) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            return this.__entries__[index][1];\r\n        }\r\n\r\n        set(key, value) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        }\r\n\r\n        delete(key) {\r\n            let entries = this.__entries__,\r\n                index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        has(key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        }\r\n    };\r\n})();\r\n\r\nconst Map = (() => {\r\n    if (hasNativeCollections) {\r\n        return window.Map;\r\n    }\r\n\r\n    return class extends WeakMap {\r\n        get size() {\r\n            return this.__entries__.length;\r\n        }\r\n\r\n        clear() {\r\n            this.__entries__.splice(0, this.__entries__.length);\r\n        }\r\n\r\n        entries() {\r\n            return this.__entries__.slice();\r\n        }\r\n\r\n        keys() {\r\n            return this.__entries__.map(entry => entry[0]);\r\n        }\r\n\r\n        values() {\r\n            return this.__entries__.map(entry => entry[1]);\r\n        }\r\n\r\n        forEach(callback, ctx = null) {\r\n            for (const entry of this.__entries__) {\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        }\r\n    };\r\n})();\r\n\r\nexport {Map, WeakMap};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/shims/es6-collections.js\n **/","import now from './shims/performance.now';\r\nimport requestAnimFrame from './shims/requestAnimationFrame';\r\n\r\nconst mutationsSupported = typeof window.MutationObserver === 'function';\r\n\r\n/**\r\n * Creates a wrapper function which ensures that\r\n * provided callback will be invoked only once\r\n * during the specified delay.\r\n *\r\n * @param {Function} callback - Function to be invoked.\r\n * @param {Number} [delay = 0] - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction debounce(callback, delay = 0) {\r\n    let timeoutID = false;\r\n\r\n    return function (...args) {\r\n        if (timeoutID !== false) {\r\n            clearTimeout(timeoutID);\r\n        }\r\n\r\n        timeoutID = setTimeout(() => {\r\n            timeoutID = false;\r\n\r\n            /* eslint-disable no-invalid-this */\r\n            callback.apply(this, args);\r\n\r\n            /* eslint-enable no-invalid-this */\r\n        }, delay);\r\n    };\r\n}\r\n\r\n/**\r\n * Controller class which handles updates of ResizeObserver instances.\r\n * It's meant to decide when and for how long it's necessary to run updates by listening to the windows\r\n * \"resize\" event along with a tracking of DOM mutations (nodes removal, changes of attributes, etc.).\r\n *\r\n * Transitions and animations are handled by running a repeatable update cycle either until the dimensions\r\n * of observed elements are changing or the timeout is reached (default timeout is 50 milliseconds).\r\n * Timeout value can be manually increased if transitions have a delay.\r\n *\r\n * Continuous update cycle will be used automatically in case if MutationObserver is not supported.\r\n */\r\nexport default class ResizeObserverController {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @param {Number} [idleTimeout = 0] - Idle timeout value.\r\n     * @param {Boolean} [continuousUpdates = false] - Whether to use a continuous update cycle.\r\n     */\r\n    constructor(idleTimeout = 50, continuousUpdates = false) {\r\n        this._idleTimeout = idleTimeout;\r\n        this._isCycleContinuous = continuousUpdates;\r\n\r\n        this._cycleStartTime = 0;\r\n\r\n        // Indicates whether the update cycle is currently running.\r\n        this._isCycleActive = false;\r\n\r\n        // Indicates whether the update of observers is scheduled.\r\n        this._isUpdateScheduled = false;\r\n\r\n        // Indicates whether DOM listeners have been added.\r\n        this._listenersEnabled = false;\r\n\r\n        // Keeps reference to the instance of MutationObserver.\r\n        this._mutationsObserver = null;\r\n\r\n        // A list of connected observers.\r\n        this._observers = [];\r\n\r\n        // Fix value of \"this\" binding for the following methods.\r\n        this.runUpdates = this.runUpdates.bind(this);\r\n        this._onMutation = this._onMutation.bind(this);\r\n        this._resolveScheduled = this._resolveScheduled.bind(this);\r\n\r\n        // Function that will be invoked to re-run the\r\n        // update cycle if continuous cycles are enabled.\r\n        this._continuousCycleHandler = debounce(this.runUpdates, 100);\r\n    }\r\n\r\n    /**\r\n     * Returns current idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    get idleTimeout() {\r\n        return this._idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout value.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    set idleTimeout(value) {\r\n        this._idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Tells whether continuous updates are enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    get continuousUpdates() {\r\n        return this._isCycleContinuous;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables continuous updates.\r\n     *\r\n     * @param {Boolean} enable - Whether to enable or disable\r\n     *      continuous updates. Note that the value won't be applied\r\n     *      if MutationObserver is not supported.\r\n     */\r\n    set continuousUpdates(enable) {\r\n        // The state of continuous updates should not be modified\r\n        // if MutationObserver is not supported.\r\n        if (!mutationsSupported) {\r\n            return;\r\n        }\r\n\r\n        this._isCycleContinuous = enable;\r\n\r\n        // Immediately start the update cycle in order not to\r\n        // wait for a possible event that will initiate it.\r\n        if (this._listenersEnabled && enable) {\r\n            this.runUpdates();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be added.\r\n     */\r\n    connect(observer) {\r\n        if (!this.isConnected(observer)) {\r\n            this._observers.push(observer);\r\n        }\r\n\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this._listenersEnabled) {\r\n            this._addListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be removed.\r\n     */\r\n    disconnect(observer) {\r\n        let observers = this._observers,\r\n            index = observers.indexOf(observer);\r\n\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n\r\n        // Remove listeners if controller\r\n        // has no connected observers.\r\n        if (!observers.length && this._listenersEnabled) {\r\n            this._removeListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether provided observer is connected to controller.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be checked.\r\n     * @returns {Boolean}\r\n     */\r\n    isConnected(observer) {\r\n        return !!~this._observers.indexOf(observer);\r\n    }\r\n\r\n    /**\r\n     * Updates every observer from observers list and\r\n     * notifies them of queued entries.\r\n     *\r\n     * @private\r\n     * @returns {Boolean} Returns \"true\" if any observer\r\n     *      has detected changes in dimensions of its' elements.\r\n     */\r\n    _updateObservers() {\r\n        let hasChanges = false;\r\n\r\n        for (const observer of this._observers) {\r\n            observer.gatherActive();\r\n\r\n            if (observer.hasActive()) {\r\n                hasChanges = true;\r\n\r\n                observer.broadcastActive();\r\n            }\r\n        }\r\n\r\n        return hasChanges;\r\n    }\r\n\r\n    /**\r\n     * Starts the update cycle which will run either\r\n     * until it detects changes in the dimensions of\r\n     * elements or the idle timeout is reached.\r\n     */\r\n    runUpdates() {\r\n        this._cycleStartTime = now();\r\n        this._isCycleActive = true;\r\n\r\n        this.scheduleUpdate();\r\n    }\r\n\r\n    /**\r\n     * Schedules the update of observers.\r\n     */\r\n    scheduleUpdate() {\r\n        // Schedule new update if it\r\n        // hasn't been scheduled already.\r\n        if (!this._isUpdateScheduled) {\r\n            this._isUpdateScheduled = true;\r\n\r\n            requestAnimFrame(this._resolveScheduled);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invokes the update of observers. It may re-run the\r\n     * cycle if changes in observers have been detected.\r\n     *\r\n     * @private\r\n     */\r\n    _resolveScheduled() {\r\n        const hasChanges = this._updateObservers();\r\n\r\n        this._isUpdateScheduled = false;\r\n\r\n        // Do nothing if cycle wasn't started,\r\n        // i.e. a single update was requested.\r\n        if (!this._isCycleActive) {\r\n            return;\r\n        }\r\n\r\n        // Re-start cycle so that we can catch future changes,\r\n        // e.g. when there are active CSS transitions.\r\n        if (hasChanges) {\r\n            this.runUpdates();\r\n        } else if (this._hasRemainingTime()) {\r\n            // Keep running updates if idle timeout isn't reached yet.\r\n            // This way we make it possible to adjust to delayed transitions.\r\n            this.scheduleUpdate();\r\n        } else {\r\n            // Finish update cycle.\r\n            this._endUpdates();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether the update cycle has time remaining.\r\n     *\r\n     * @private\r\n     * @returns {Boolean}\r\n     */\r\n    _hasRemainingTime() {\r\n        const timePassed = now() - this._cycleStartTime;\r\n\r\n        return this._idleTimeout - timePassed > 0;\r\n    }\r\n\r\n    /**\r\n     * Callback which is invoked when update cycle\r\n     * is finished. It may start a new cycle if continuous\r\n     * updates are enabled.\r\n     *\r\n     * @private\r\n     */\r\n    _endUpdates() {\r\n        this._isCycleActive = false;\r\n\r\n        if (this._isCycleContinuous && this._listenersEnabled) {\r\n            this._continuousCycleHandler();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _addListeners() {\r\n        // Do nothing if listeners have been already added.\r\n        if (this._listenersEnabled) {\r\n            return;\r\n        }\r\n\r\n        this._listenersEnabled = true;\r\n\r\n        // Repeatable cycle is used here because the resize event may\r\n        // lead to continuous changes, e.g. when width or height of an element\r\n        // are controlled by CSS transitions.\r\n        window.addEventListener('resize', this.runUpdates);\r\n\r\n        // Fall back to an infinite cycle.\r\n        if (!mutationsSupported) {\r\n            this._isCycleContinuous = true;\r\n        } else {\r\n            // Subscribe to DOM mutations as they may lead to\r\n            // changes in dimensions of elements.\r\n            this._mutationsObserver = new MutationObserver(this._onMutation);\r\n\r\n            this._mutationsObserver.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n\r\n        // Don't wait for possible event that might trigger the\r\n        // update of observers and manually initiate update cycle.\r\n        if (this._isCycleContinuous) {\r\n            this.runUpdates();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _removeListeners() {\r\n        // Do nothing if listeners have been already removed.\r\n        if (!this._listenersEnabled) {\r\n            return;\r\n        }\r\n\r\n        window.removeEventListener('resize', this.runUpdates);\r\n\r\n        if (this._mutationsObserver) {\r\n            this._mutationsObserver.disconnect();\r\n        }\r\n\r\n        this._mutationsObserver = null;\r\n        this._listenersEnabled = false;\r\n    }\r\n\r\n    /**\r\n     * DOM mutations handler.\r\n     *\r\n     * @private\r\n     * @param {Array<MutationRecord>} entries - An array of mutation records.\r\n     */\r\n    _onMutation(entries) {\r\n        // Check if at least one entry\r\n        // contains attributes changes.\r\n        const attrsChanged = entries.some(entry => {\r\n            return entry.type === 'attributes';\r\n        });\r\n\r\n        // It's expected that animations may start only\r\n        // after some attribute changes its' value.\r\n        attrsChanged ?\r\n            this.runUpdates() :\r\n            this.scheduleUpdate();\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ResizeObserverController.js\n **/","/**\r\n * A shim for performance.now method which falls back\r\n * to Date.now if the first one is not supported.\r\n *\r\n * @returns {Timestamp}\r\n */\r\nexport default (() => {\r\n    if (\r\n        window.performance &&\r\n        typeof window.performance.now === 'function'\r\n    ) {\r\n        return () => window.performance.now();\r\n    }\r\n\r\n    return () => Date.now();\r\n})();\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/shims/performance.now.js\n **/","/**\r\n * A shim for requestAnimationFrame which falls back\r\n * to setTimeout if the first one is not supported.\r\n *\r\n * @returns {Number} Requests' identifier.\r\n */\r\nexport default (() => {\r\n    if (\r\n        window.requestAnimationFrame &&\r\n        typeof window.requestAnimationFrame === 'function'\r\n    ) {\r\n        return window.requestAnimationFrame;\r\n    }\r\n\r\n    return callback => {\r\n        return setTimeout(() => callback(Date.now()), 1000 / 60);\r\n    };\r\n})();\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/shims/requestAnimationFrame.js\n **/","import {Map} from './shims/es6-collections';\r\nimport ResizeObservation from './ResizeObservation';\r\nimport ResizeObserverEntry from './ResizeObserverEntry';\r\n\r\nexport default class ResizeObserver {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {Function} callback - Callback function which will be invoked\r\n     *      when one of the observed elements changes its' content rectangle.\r\n     * @param {ResizeObsreverController} controller - Controller instance\r\n     *      which is responsible for the updates of observer.\r\n     * @param {ResizeObserver} publicObserver - Reference\r\n     *      to the public ResizeObserver instance which will be passed\r\n     *      to callback function.\r\n     */\r\n    constructor(callback, controller, publicObserver) {\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n\r\n        // Reference to the callback function.\r\n        this._callback = callback;\r\n\r\n        // A registry of ResizeObservation instances.\r\n        this._targets = new Map();\r\n\r\n        // A collection of resize observations that have detected\r\n        // changes in dimensions of elements.\r\n        this._activeTargets = [];\r\n\r\n        // Reference to associated ResizeObserverController.\r\n        this._controller = controller;\r\n\r\n        // Public ResizeObserver instance which will be passed\r\n        // to callback function.\r\n        this._publicObserver = publicObserver;\r\n    }\r\n\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    observe(target) {\r\n        //  Throw the same errors as in a native implementation.\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const targets = this._targets;\r\n\r\n        // Do nothing if element is already being observed.\r\n        if (targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        targets.set(target, new ResizeObservation(target));\r\n\r\n        // Add observer to controller if\r\n        // it hasn't been connected yet.\r\n        if (!this._controller.isConnected(this)) {\r\n            this._controller.connect(this);\r\n        }\r\n\r\n        // Update observations.\r\n        this._controller.runUpdates();\r\n    }\r\n\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     */\r\n    unobserve(target) {\r\n        //  Throw the same errors as in a native implementation.\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const targets = this._targets;\r\n\r\n        // Do nothing if element is not being observed.\r\n        if (!targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        // Remove element and associated with\r\n        // it ResizeObsrvation instance from registry.\r\n        targets.delete(target);\r\n\r\n        // Set back the initial state if\r\n        // there is nothing to observe.\r\n        if (!targets.size) {\r\n            this.disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops observing all elements and\r\n     * clears the observations list.\r\n     */\r\n    disconnect() {\r\n        this.clearActive();\r\n        this._targets.clear();\r\n        this._controller.disconnect(this);\r\n    }\r\n\r\n    /**\r\n     * Invokes initial callback function with a list\r\n     * of ResizeObserverEntry instances collected from\r\n     * active resize observations.\r\n     */\r\n    broadcastActive() {\r\n        // Do nothing if observer doesn't\r\n        // have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n\r\n        const publicObserver = this._publicObserver;\r\n\r\n        // Create ResizeObserverEntry instance\r\n        // for every active observation.\r\n        const entries = this._activeTargets.map(observation => {\r\n            return new ResizeObserverEntry(\r\n                observation.target,\r\n                observation.broadcastRect()\r\n            );\r\n        });\r\n\r\n        this.clearActive();\r\n\r\n        this._callback.call(publicObserver, entries, publicObserver);\r\n    }\r\n\r\n    /**\r\n     * Clears the collection of pending/active observations.\r\n     */\r\n    clearActive() {\r\n        this._activeTargets.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Tells whether the observer has\r\n     * pending observations.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    hasActive() {\r\n        return !!this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Clears an array of previously collected active observations\r\n     * and collects observation instances whose associated element\r\n     * has changes in its' content rectangle.\r\n     */\r\n    gatherActive() {\r\n        this.clearActive();\r\n\r\n        const activeTargets = this._activeTargets;\r\n\r\n        this._targets.forEach(observation => {\r\n            if (observation.isActive()) {\r\n                activeTargets.push(observation);\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_ResizeObserver.js\n **/","// Placeholder of a content rectangle.\r\nconst emptyRect = createContentRect(0, 0, 0, 0);\r\n\r\n/**\r\n * Extracts computed styles of provided element.\r\n *\r\n * @param {Element} target\r\n * @returns {CSSStyleDeclaration}\r\n */\r\nfunction getStyles(target) {\r\n    return window.getComputedStyle(target);\r\n}\r\n\r\n/**\r\n * Converts provided string defined\r\n * in q form of '{{value}}px' to number.\r\n *\r\n * @param {String} value\r\n * @returns {Number}\r\n */\r\nfunction pixelsToNumber(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...String} positions - Borders positions (top, right, ...)\r\n * @returns {Number}\r\n */\r\nfunction getBordersSize(styles, ...positions) {\r\n    return positions.reduce((size, pos) => {\r\n        const value = styles['border-' + pos + '-width'];\r\n\r\n        return size + pixelsToNumber(value);\r\n    }, 0);\r\n}\r\n\r\n/**\r\n *  Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    const boxKeys = ['top', 'right', 'bottom', 'left'];\r\n    const paddings = {};\r\n\r\n    for (const key of boxKeys) {\r\n        const value = styles['padding-' + key];\r\n\r\n        paddings[key] = pixelsToNumber(value);\r\n    }\r\n\r\n    return paddings;\r\n}\r\n\r\n/**\r\n * Creates content rectangle based on the provided dimensions\r\n * and the top/left positions.\r\n *\r\n * @param {Number} width - Width of rectangle.\r\n * @param {Number} height - Height of rectangle.\r\n * @param {Number} top - Top position.\r\n * @param {Number} left - Left position.\r\n * @returns {ClientRect}\r\n */\r\nfunction createContentRect(width, height, top, left) {\r\n    return {\r\n        width, height, top,\r\n        right: width + left,\r\n        bottom: height + top,\r\n        left\r\n    };\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGElement} target - Element whose content\r\n *      rectangle needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    const bbox = target.getBBox();\r\n\r\n    return createContentRect(bbox.width, bbox.height, 0, 0);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of a root element.\r\n *\r\n * @returns {ClientRect}\r\n */\r\nfunction getDocElementRect() {\r\n    // Neither scroll[Width/Height] nor offset[Width/Height] can be used to define\r\n    // content dimensions as they give inconsistent results across different browser.\r\n    // E.g. in Internet Explorer 10 and lower these properties can't be less than\r\n    // client dimensions (same thing with the \"getBoundingClientRect\" method).\r\n    // And Firefox has the same behavior with its \"scroll\" properties.\r\n    const styles = getStyles(document.documentElement);\r\n\r\n    const width = pixelsToNumber(styles.width);\r\n    const height = pixelsToNumber(styles.height);\r\n\r\n    return createContentRect(width, height, 0, 0);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element whose content\r\n *      rectangle needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    const clientWidth = target.clientWidth;\r\n    const clientHeight = target.clientHeight;\r\n\r\n    // By this condition we can catch all non-replaced inline, hidden and detached\r\n    // elements. Though elements whose width & height are less than 0.5 will\r\n    // be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuerys' ':visible' filter\r\n    // gives wrong results for elements whose width & height are less\r\n    // than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n\r\n    const styles = getStyles(target);\r\n    const paddings = getPaddings(styles);\r\n    const horizPad = paddings.left + paddings.right;\r\n    const vertPad = paddings.top + paddings.bottom;\r\n\r\n    // Computed styles of width & height are being used because they\r\n    // are the only dimensions available to JS that contain non-rounded values. It could\r\n    // have been possible to utilize getBoundingClientRect if only its' data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    let width = pixelsToNumber(styles.width),\r\n        height = pixelsToNumber(styles.height);\r\n\r\n    // Width & height include paddings and borders\r\n    // when 'border-box' box model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\" properties\r\n        // then it's either IE, and thus we don't need to subtract anything, or\r\n        // an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n\r\n    // In some browsers (only in Firefox, actually) CSS width & height\r\n    // include scroll bars size which can be removed at this step as scroll bars\r\n    // are the only difference between rounded dimensions + paddings\r\n    // and \"client\" properties, though that is not always true in Chrome.\r\n    const vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n    const horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n\r\n    // Chrome has a rather weird rounding of \"client\" properties.\r\n    // E.g. for an element whose content width is 314.2px it sometimes\r\n    // gives the client width of 315px and for the width of 314.7px\r\n    // it may give 314px. And it doesn't happen all the time.\r\n    // This kind of difference needs to be ignored.\r\n    if (Math.abs(vertScrollbar) !== 1) {\r\n        width -= vertScrollbar;\r\n    }\r\n\r\n    if (Math.abs(horizScrollbar) !== 1) {\r\n        height -= horizScrollbar;\r\n    }\r\n\r\n    return createContentRect(width, height, paddings.top, paddings.left);\r\n}\r\n\r\n/**\r\n * Checks whether provided element\r\n * is an instance of SVGElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {Boolean}\r\n */\r\nfunction isSVGElement(target) {\r\n    return target instanceof window.SVGElement;\r\n}\r\n\r\n/**\r\n * Checks whether provided element is\r\n * a document element (root element of a document).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {Boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === document.documentElement;\r\n}\r\n\r\n/**\r\n * Calculates an appropriate content rectangle\r\n * for provided html or svg element.\r\n *\r\n * @param {Element} target - Element whose content rectangle\r\n *      needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getContentRect(target) {\r\n    if (isSVGElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n\r\n    if (isDocumentElement(target)) {\r\n        return getDocElementRect();\r\n    }\r\n\r\n    return getHTMLElementContentRect(target);\r\n}\r\n\r\n/**\r\n * Class that is responsible for computations of the\r\n * content rectangle of provided DOM element and\r\n * for keeping track of its' changes.\r\n */\r\nexport default class ResizeObservation {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element whose content\r\n     *      rectangle needs to be observed.\r\n     */\r\n    constructor(target) {\r\n        this.target = target;\r\n\r\n        // Keeps reference to the last observed content rectangle.\r\n        this._contentRect = emptyRect;\r\n\r\n        // Broadcasted width of content rectangle.\r\n        this.broadcastWidth = 0;\r\n\r\n        // Broadcasted height of content rectangle.\r\n        this.broadcastHeight = 0;\r\n    }\r\n\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight'\r\n     * properties with a data from the corresponding\r\n     * properties of the last observed content rectangle.\r\n     *\r\n     * @returns {ClientRect} Last observed content rectangle.\r\n     */\r\n    broadcastRect() {\r\n        const rect = this._contentRect;\r\n\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n\r\n        return rect;\r\n    }\r\n\r\n    /**\r\n     * Updates content rectangle and tells whether its'\r\n     * width or height properties have changed since\r\n     * the last broadcast.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isActive() {\r\n        const rect = getContentRect(this.target);\r\n\r\n        this._contentRect = rect;\r\n\r\n        return (\r\n            rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight\r\n        );\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ResizeObservation.js\n **/","export default class ResizeObserverEntry {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {ClientRect} rectData - Data of the elements' content rectangle.\r\n     */\r\n    constructor(target, rectData) {\r\n        // Content rectangle needs to be an instance\r\n        // of ClientRect if it's available.\r\n        const rectInterface = window.ClientRect ?\r\n            ClientRect.prototype :\r\n            Object.prototype;\r\n\r\n        // According to the specification following properties\r\n        // are not writable and in native implementation\r\n        // they are also not enumerable.\r\n        const contentRect = Object.create(rectInterface, {\r\n            width: {value: rectData.width},\r\n            height: {value: rectData.height},\r\n            top: {value: rectData.top},\r\n            right: {value: rectData.right},\r\n            bottom: {value: rectData.bottom},\r\n            left: {value: rectData.left}\r\n        });\r\n\r\n        Object.defineProperties(this, {\r\n            target: {value: target},\r\n            contentRect: {value: contentRect}\r\n        });\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/ResizeObserverEntry.js\n **/"],"sourceRoot":""}