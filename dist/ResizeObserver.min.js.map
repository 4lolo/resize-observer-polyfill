{"version":3,"file":null,"sources":["../src/ResizeObserverController.js","../src/ResizeObservation.js","../src/ResizeObserverEntry.js","../src/shims/es6-collections.js","../src/shims/performance.now.js","../src/shims/requestAnimationFrame.js","../src/_ResizeObserver.js","../src/ResizeObserver.js","../index.js"],"sourcesContent":["import now from './shims/performance.now';\r\nimport requestAnimFrame from './shims/requestAnimationFrame';\r\n\r\nconst mutationsSupported = typeof window.MutationObserver === 'function';\r\n\r\n/**\r\n * Creates a wrapper function which ensures only one invocation of provided\r\n * callback during the specified delay.\r\n *\r\n * @param {Function} callback - Function to be invoked.\r\n * @param {Number} [delay = 0] - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction debounce(callback, delay = 0) {\r\n    let timeoutID = false;\r\n\r\n    return function (...args) {\r\n        if (timeoutID !== false) {\r\n            clearTimeout(timeoutID);\r\n        }\r\n\r\n        timeoutID = setTimeout(() => {\r\n            timeoutID = false;\r\n\r\n            // eslint-disable-next-line no-invalid-this\r\n            callback.apply(this, args);\r\n        }, delay);\r\n    };\r\n}\r\n\r\n/**\r\n * Controller class which handles updates of ResizeObserver instances.\r\n * It's meant to decide when and for how long it's necessary to run updates by\r\n * listening to the windows \"resize\" event along with a tracking of DOM mutations\r\n * (nodes removal, changes of attributes, etc.).\r\n *\r\n * Transitions and animations are handled by running a repeatable update cycle\r\n * either until the dimensions of observed elements are changing or the timeout\r\n * is reached (default timeout is 50 milliseconds). Timeout value can be manually\r\n * increased if transitions have a delay.\r\n *\r\n * Continuous update cycle will be used automatically in case if MutationObserver\r\n * is not supported.\r\n */\r\nexport default class ResizeObserverController {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @param {Number} [idleTimeout = 0] - Idle timeout value.\r\n     * @param {Boolean} [continuousUpdates = false] - Whether to use a continuous\r\n     *      update cycle.\r\n     */\r\n    constructor(idleTimeout = 50, continuousUpdates = false) {\r\n        this._idleTimeout = idleTimeout;\r\n        this._isCycleContinuous = !mutationsSupported || continuousUpdates;\r\n\r\n        this._cycleStartTime = 0;\r\n\r\n        // Indicates whether the update cycle is currently running.\r\n        this._isCycleActive = false;\r\n\r\n        // Indicates whether the update of observers is scheduled.\r\n        this._isUpdateScheduled = false;\r\n\r\n        // Indicates whether DOM listeners have been added.\r\n        this._listenersEnabled = false;\r\n\r\n        // Keeps reference to the instance of MutationObserver.\r\n        this._mutationsObserver = null;\r\n\r\n        // A list of connected observers.\r\n        this._observers = [];\r\n\r\n        // Fix value of \"this\" binding for the following methods.\r\n        this.runUpdates = this.runUpdates.bind(this);\r\n        this._onMutation = this._onMutation.bind(this);\r\n        this._resolveScheduled = this._resolveScheduled.bind(this);\r\n\r\n        // Function that will be invoked to re-run the update cycle if continuous\r\n        // cycles are enabled.\r\n        this._continuousCycleHandler = debounce(this.runUpdates, 100);\r\n    }\r\n\r\n    /**\r\n     * Returns current idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    get idleTimeout() {\r\n        return this._idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout value.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    set idleTimeout(value) {\r\n        this._idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Tells whether continuous updates are enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    get continuousUpdates() {\r\n        return this._isCycleContinuous;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables continuous updates.\r\n     *\r\n     * @param {Boolean} useContinuous - Whether to enable or disable continuous\r\n     *      updates. Note that the value won't be applied if MutationObserver is\r\n     *      not supported.\r\n     */\r\n    set continuousUpdates(useContinuous) {\r\n        // The state of continuous updates should not be modified if\r\n        // MutationObserver is not supported.\r\n        if (!mutationsSupported) {\r\n            return;\r\n        }\r\n\r\n        this._isCycleContinuous = useContinuous;\r\n\r\n        // Immediately start the update cycle in order not to wait for a possible\r\n        // event that will initiate it.\r\n        if (this._listenersEnabled && useContinuous) {\r\n            this.runUpdates();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be added.\r\n     */\r\n    connect(observer) {\r\n        if (!this.isConnected(observer)) {\r\n            this._observers.push(observer);\r\n        }\r\n\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this._listenersEnabled) {\r\n            this._addListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be removed.\r\n     */\r\n    disconnect(observer) {\r\n        let observers = this._observers,\r\n            index = observers.indexOf(observer);\r\n\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this._listenersEnabled) {\r\n            this._removeListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether provided observer is connected to controller.\r\n     *\r\n     * @param {ResizeObserver} observer - Observer to be checked.\r\n     * @returns {Boolean}\r\n     */\r\n    isConnected(observer) {\r\n        return !!~this._observers.indexOf(observer);\r\n    }\r\n\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {Boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of its' elements.\r\n     */\r\n    _updateObservers() {\r\n        let hasChanges = false;\r\n\r\n        for (const observer of this._observers) {\r\n            observer.gatherActive();\r\n\r\n            if (observer.hasActive()) {\r\n                hasChanges = true;\r\n\r\n                observer.broadcastActive();\r\n            }\r\n        }\r\n\r\n        return hasChanges;\r\n    }\r\n\r\n    /**\r\n     * Starts the update cycle which runs either until it detects changes in the\r\n     * dimensions of elements or the idle timeout is reached.\r\n     */\r\n    runUpdates() {\r\n        this._cycleStartTime = now();\r\n        this._isCycleActive = true;\r\n\r\n        this.scheduleUpdate();\r\n    }\r\n\r\n    /**\r\n     * Schedules the update of observers.\r\n     */\r\n    scheduleUpdate() {\r\n        // Schedule new update if it hasn't been scheduled already.\r\n        if (!this._isUpdateScheduled) {\r\n            this._isUpdateScheduled = true;\r\n\r\n            requestAnimFrame(this._resolveScheduled);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invokes the update of observers. It may re-run the active update cycle if\r\n     * it detects changes in observers.\r\n     *\r\n     * @private\r\n     */\r\n    _resolveScheduled() {\r\n        const hasChanges = this._updateObservers();\r\n\r\n        this._isUpdateScheduled = false;\r\n\r\n        // Do nothing if cycle wasn't started, i.e. a single update was requested.\r\n        if (!this._isCycleActive) {\r\n            return;\r\n        }\r\n\r\n        // Re-start cycle so that we can catch future changes, e.g. when there\r\n        // are active CSS transitions.\r\n        if (hasChanges) {\r\n            this.runUpdates();\r\n        } else if (this._hasRemainingTime()) {\r\n            // Keep running updates if idle timeout isn't reached yet. This way\r\n            // we make it possible to adjust to delayed transitions.\r\n            this.scheduleUpdate();\r\n        } else {\r\n            // Finish update cycle.\r\n            this._endUpdates();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether the update cycle has time remaining.\r\n     *\r\n     * @private\r\n     * @returns {Boolean}\r\n     */\r\n    _hasRemainingTime() {\r\n        const timePassed = now() - this._cycleStartTime;\r\n\r\n        return this._idleTimeout - timePassed > 0;\r\n    }\r\n\r\n    /**\r\n     * Callback which is invoked when update cycle is finished. It may start a\r\n     * new cycle if continuous updates are enabled.\r\n     *\r\n     * @private\r\n     */\r\n    _endUpdates() {\r\n        this._isCycleActive = false;\r\n\r\n        // Automatically repeat cycle if it's necessary.\r\n        if (this._isCycleContinuous && this._listenersEnabled) {\r\n            this._continuousCycleHandler();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _addListeners() {\r\n        // Do nothing if listeners have been already added.\r\n        if (this._listenersEnabled) {\r\n            return;\r\n        }\r\n\r\n        this._listenersEnabled = true;\r\n\r\n        // Repeatable cycle is used here because the resize event may lead to\r\n        // continuous changes, e.g. when width or height of an element are\r\n        // controlled by CSS transitions.\r\n        window.addEventListener('resize', this.runUpdates);\r\n\r\n        // Subscribe to DOM mutations if it's possible as they may lead to changes\r\n        // in the dimensions of elements.\r\n        if (mutationsSupported) {\r\n            this._mutationsObserver = new MutationObserver(this._onMutation);\r\n\r\n            this._mutationsObserver.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n\r\n        // Don't wait for a possible event that might trigger the update of\r\n        // observers and manually initiate the update cycle.\r\n        if (this._isCycleContinuous) {\r\n            this.runUpdates();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _removeListeners() {\r\n        // Do nothing if listeners have been already removed.\r\n        if (!this._listenersEnabled) {\r\n            return;\r\n        }\r\n\r\n        window.removeEventListener('resize', this.runUpdates);\r\n\r\n        if (this._mutationsObserver) {\r\n            this._mutationsObserver.disconnect();\r\n        }\r\n\r\n        this._mutationsObserver = null;\r\n        this._listenersEnabled = false;\r\n    }\r\n\r\n    /**\r\n     * DOM mutations handler.\r\n     *\r\n     * @private\r\n     * @param {Array<MutationRecord>} entries - An array of mutation records.\r\n     */\r\n    _onMutation(entries) {\r\n        // Check if at least one entry contains attributes changes.\r\n        const attrsChanged = entries.some(entry => {\r\n            return entry.type === 'attributes';\r\n        });\r\n\r\n        // It's expected that animations may start only after some attribute\r\n        // changes its' value.\r\n        attrsChanged ?\r\n            this.runUpdates() :\r\n            this.scheduleUpdate();\r\n    }\r\n}\r\n","// Placeholder of an empty content rectangle.\r\nconst emptyRect = createContentRect(0, 0, 0, 0);\r\n\r\n/**\r\n * Extracts computed styles of provided element.\r\n *\r\n * @param {Element} target\r\n * @returns {CSSStyleDeclaration}\r\n */\r\nfunction getStyles(target) {\r\n    return window.getComputedStyle(target);\r\n}\r\n\r\n/**\r\n * Converts provided string defined in q form of '{{value}}px' to number.\r\n *\r\n * @param {String} value\r\n * @returns {Number}\r\n */\r\nfunction pixelsToNumber(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...String} positions - Borders positions (top, right, ...)\r\n * @returns {Number}\r\n */\r\nfunction getBordersSize(styles, ...positions) {\r\n    return positions.reduce((size, pos) => {\r\n        const value = styles['border-' + pos + '-width'];\r\n\r\n        return size + pixelsToNumber(value);\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    const boxKeys = ['top', 'right', 'bottom', 'left'];\r\n    const paddings = {};\r\n\r\n    for (const key of boxKeys) {\r\n        const value = styles['padding-' + key];\r\n\r\n        paddings[key] = pixelsToNumber(value);\r\n    }\r\n\r\n    return paddings;\r\n}\r\n\r\n/**\r\n * Creates content rectangle based on the provided dimensions\r\n * and the top/left positions.\r\n *\r\n * @param {Number} width - Width of rectangle.\r\n * @param {Number} height - Height of rectangle.\r\n * @param {Number} top - Top position.\r\n * @param {Number} left - Left position.\r\n * @returns {ClientRect}\r\n */\r\nfunction createContentRect(width, height, top, left) {\r\n    return {\r\n        width, height, top,\r\n        right: width + left,\r\n        bottom: height + top,\r\n        left\r\n    };\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGElement} target - Element whose content\r\n *      rectangle needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    const bbox = target.getBBox();\r\n\r\n    return createContentRect(bbox.width, bbox.height, 0, 0);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of a root element.\r\n *\r\n * @returns {ClientRect}\r\n */\r\nfunction getDocElementRect() {\r\n    // Neither scroll[Width/Height] nor offset[Width/Height] can be used to\r\n    // define content dimensions as they give inconsistent results across\r\n    // different browsers. E.g. in the Internet Explorer 10 and lower value of\r\n    // these properties can't be less than the client dimensions (same thing\r\n    // with the \"getBoundingClientRect\" method). And Firefox has the same\r\n    // behavior with its \"scroll\" properties.\r\n    const styles = getStyles(document.documentElement);\r\n\r\n    const width = pixelsToNumber(styles.width);\r\n    const height = pixelsToNumber(styles.height);\r\n\r\n    return createContentRect(width, height, 0, 0);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element whose content\r\n *      rectangle needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    const clientWidth = target.clientWidth;\r\n    const clientHeight = target.clientHeight;\r\n\r\n    // By this condition we can catch all non-replaced inline, hidden and detached\r\n    // elements. Though elements with width & height properties less than 0.5 will\r\n    // be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuerys' ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n\r\n    const styles = getStyles(target);\r\n    const paddings = getPaddings(styles);\r\n    const horizPad = paddings.left + paddings.right;\r\n    const vertPad = paddings.top + paddings.bottom;\r\n\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize getBoundingClientRect if only its' data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    let width = pixelsToNumber(styles.width),\r\n        height = pixelsToNumber(styles.height);\r\n\r\n    // Width & height include paddings and borders\r\n    // when 'border-box' box model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n\r\n    // In some browsers (only in Firefox, actually) CSS width & height\r\n    // include scroll bars size which can be removed at this step as scroll bars\r\n    // are the only difference between rounded dimensions + paddings and \"client\"\r\n    // properties, though that is not always true in Chrome.\r\n    const vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n    const horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n\r\n    // Chrome has a rather weird rounding of \"client\" properties.\r\n    // E.g. for an element whose content width is 314.2px it sometimes gives the\r\n    // client width of 315px and for the width of 314.7px it may give 314px.\r\n    // And it doesn't happen all the time. This kind of difference needs to be\r\n    // ignored.\r\n    if (Math.abs(vertScrollbar) !== 1) {\r\n        width -= vertScrollbar;\r\n    }\r\n\r\n    if (Math.abs(horizScrollbar) !== 1) {\r\n        height -= horizScrollbar;\r\n    }\r\n\r\n    return createContentRect(width, height, paddings.top, paddings.left);\r\n}\r\n\r\n/**\r\n * Checks whether provided element is an instance of SVGElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {Boolean}\r\n */\r\nfunction isSVGElement(target) {\r\n    return target instanceof window.SVGElement;\r\n}\r\n\r\n/**\r\n * Checks whether provided element is a document element (root element of a document).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {Boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === document.documentElement;\r\n}\r\n\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element whose content rectangle\r\n *      needs to be calculated.\r\n * @returns {ClientRect}\r\n */\r\nfunction getContentRect(target) {\r\n    if (isSVGElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n\r\n    if (isDocumentElement(target)) {\r\n        return getDocElementRect();\r\n    }\r\n\r\n    return getHTMLElementContentRect(target);\r\n}\r\n\r\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of its' changes.\r\n */\r\nexport default class ResizeObservation {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element whose content rectangle needs to be observed.\r\n     */\r\n    constructor(target) {\r\n        this.target = target;\r\n\r\n        // Keeps reference to the last observed content rectangle.\r\n        this._contentRect = emptyRect;\r\n\r\n        // Broadcasted width of content rectangle.\r\n        this.broadcastWidth = 0;\r\n\r\n        // Broadcasted height of content rectangle.\r\n        this.broadcastHeight = 0;\r\n    }\r\n\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {ClientRect} Last observed content rectangle.\r\n     */\r\n    broadcastRect() {\r\n        const rect = this._contentRect;\r\n\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n\r\n        return rect;\r\n    }\r\n\r\n    /**\r\n     * Updates content rectangle and tells whether its' width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isActive() {\r\n        const rect = getContentRect(this.target);\r\n\r\n        this._contentRect = rect;\r\n\r\n        return (\r\n            rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight\r\n        );\r\n    }\r\n}\r\n","/**\r\n * Defines properties for the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @param {Object} [descr = {}] - Descriptor of the properties.\r\n * @returns {Object} Target object.\r\n */\r\nfunction defineProperties(target, props, descr = {}) {\r\n    const descriptor = {\r\n        configurable: descr.configurable || false,\r\n        writable: descr.writable || false,\r\n        enumerable: descr.enumerable || false\r\n    };\r\n\r\n    for (const key of Object.keys(props)) {\r\n        descriptor.value = props[key];\r\n\r\n        Object.defineProperty(target, key, descriptor);\r\n    }\r\n\r\n    return target;\r\n}\r\n\r\nexport default class ResizeObserverEntry {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {ClientRect} rectData - Data of the elements' content rectangle.\r\n     */\r\n    constructor(target, rectData) {\r\n        // Content rectangle needs to be an instance of ClientRect if it's\r\n        // available.\r\n        const rectInterface = window.ClientRect ?\r\n            ClientRect.prototype :\r\n            Object.prototype;\r\n\r\n        const contentRect = Object.create(rectInterface);\r\n\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineProperties(contentRect, rectData, {configurable: true});\r\n\r\n        defineProperties(this, {\r\n            target, contentRect\r\n        }, {configurable: true});\r\n    }\r\n}\r\n","/**\r\n * A collection of shims that provides minimal\r\n * support of WeakMap and Map classes.\r\n *\r\n * These implementations are not meant to be used outside of\r\n * ResizeObserver modules as they cover only a limited range\r\n * of use cases.\r\n */\r\n\r\n/* eslint-disable require-jsdoc */\r\nconst hasNativeCollections =\r\n    typeof window.WeakMap === 'function' &&\r\n    typeof window.Map === 'function';\r\n\r\nconst WeakMap = (() => {\r\n    if (hasNativeCollections) {\r\n        return window.WeakMap;\r\n    }\r\n\r\n    function getIndex(arr, key) {\r\n        let result = -1;\r\n\r\n        arr.some((entry, index) => {\r\n            let matches = entry[0] === key;\r\n\r\n            if (matches) {\r\n                result = index;\r\n            }\r\n\r\n            return matches;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return class {\r\n        constructor() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        get(key) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            return this.__entries__[index][1];\r\n        }\r\n\r\n        set(key, value) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        }\r\n\r\n        delete(key) {\r\n            let entries = this.__entries__,\r\n                index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        has(key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        }\r\n    };\r\n})();\r\n\r\nconst Map = (() => {\r\n    if (hasNativeCollections) {\r\n        return window.Map;\r\n    }\r\n\r\n    return class extends WeakMap {\r\n        get size() {\r\n            return this.__entries__.length;\r\n        }\r\n\r\n        clear() {\r\n            this.__entries__.splice(0, this.__entries__.length);\r\n        }\r\n\r\n        entries() {\r\n            return this.__entries__.slice();\r\n        }\r\n\r\n        keys() {\r\n            return this.__entries__.map(entry => entry[0]);\r\n        }\r\n\r\n        values() {\r\n            return this.__entries__.map(entry => entry[1]);\r\n        }\r\n\r\n        forEach(callback, ctx = null) {\r\n            for (const entry of this.__entries__) {\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        }\r\n    };\r\n})();\r\n\r\nexport {Map, WeakMap};\r\n","/**\r\n * A shim for performance.now method which falls back\r\n * to Date.now if the first one is not supported.\r\n *\r\n * @returns {Timestamp}\r\n */\r\nexport default (() => {\r\n    if (\r\n        window.performance &&\r\n        typeof window.performance.now === 'function'\r\n    ) {\r\n        return () => window.performance.now();\r\n    }\r\n\r\n    return () => Date.now();\r\n})();\r\n","/**\r\n * A shim for requestAnimationFrame which falls back\r\n * to setTimeout if the first one is not supported.\r\n *\r\n * @returns {Number} Requests' identifier.\r\n */\r\nexport default (() => {\r\n    if (\r\n        window.requestAnimationFrame &&\r\n        typeof window.requestAnimationFrame === 'function'\r\n    ) {\r\n        return window.requestAnimationFrame;\r\n    }\r\n\r\n    return callback => {\r\n        return setTimeout(() => callback(Date.now()), 1000 / 60);\r\n    };\r\n})();\r\n","import {Map} from './shims/es6-collections';\r\nimport ResizeObservation from './ResizeObservation';\r\nimport ResizeObserverEntry from './ResizeObserverEntry';\r\n\r\nexport default class ResizeObserver {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {Function} callback - Callback function which will be invoked when\r\n     *      one of the observed elements changes its' content rectangle.\r\n     * @param {ResizeObsreverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} publicObserver - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    constructor(callback, controller, publicObserver) {\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n\r\n        // Reference to the callback function.\r\n        this._callback = callback;\r\n\r\n        // Registry of ResizeObservation instances.\r\n        this._targets = new Map();\r\n\r\n        // Collection of resize observations that have detected changes in\r\n        // dimensions of elements.\r\n        this._activeTargets = [];\r\n\r\n        // Reference to the associated ResizeObserverController.\r\n        this._controller = controller;\r\n\r\n        // Public ResizeObserver instance which will be passed to callback function.\r\n        this._publicObserver = publicObserver;\r\n    }\r\n\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    observe(target) {\r\n        //  Throw the same errors as in a native implementation.\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const targets = this._targets;\r\n\r\n        // Do nothing if element is already being observed.\r\n        if (targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        const observation = new ResizeObservation(target);\r\n\r\n        targets.set(target, observation);\r\n\r\n        // Add observer to controller if it hasn't been connected yet.\r\n        if (!this._controller.isConnected(this)) {\r\n            this._controller.connect(this);\r\n        }\r\n\r\n        // Update observations.\r\n        this._controller.runUpdates();\r\n    }\r\n\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     */\r\n    unobserve(target) {\r\n        //  Throw the same errors as in a native implementation.\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const targets = this._targets;\r\n\r\n        // Do nothing if element is not being observed.\r\n        if (!targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        // Remove element and associated with it ResizeObsrvation instance from\r\n        // registry.\r\n        targets.delete(target);\r\n\r\n        // Set back the initial state if there is nothing to observe.\r\n        if (!targets.size) {\r\n            this.disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops observing all elements and clears the observations list.\r\n     */\r\n    disconnect() {\r\n        this.clearActive();\r\n        this._targets.clear();\r\n        this._controller.disconnect(this);\r\n    }\r\n\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     */\r\n    broadcastActive() {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n\r\n        const observer = this._publicObserver;\r\n\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        const entries = this._activeTargets.map(observation => {\r\n            return new ResizeObserverEntry(\r\n                observation.target,\r\n                observation.broadcastRect()\r\n            );\r\n        });\r\n\r\n        this.clearActive();\r\n        this._callback.call(observer, entries, observer);\r\n    }\r\n\r\n    /**\r\n     * Clears the collection of pending/active observations.\r\n     */\r\n    clearActive() {\r\n        this._activeTargets.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Tells whether the observer has pending observations.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    hasActive() {\r\n        return !!this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Clears an array of previously collected active observations and collects\r\n     * observation instances which associated element has changed its' content\r\n     * rectangle.\r\n     */\r\n    gatherActive() {\r\n        this.clearActive();\r\n\r\n        const activeTargets = this._activeTargets;\r\n\r\n        this._targets.forEach(observation => {\r\n            if (observation.isActive()) {\r\n                activeTargets.push(observation);\r\n            }\r\n        });\r\n    }\r\n}\r\n","import {WeakMap} from './shims/es6-collections';\r\nimport ResizeObserverController from './ResizeObserverController';\r\nimport _ResizeObserver from './_ResizeObserver';\r\n\r\n// Controller that will be assigned to all instances of ResizeObserver.\r\nconst controller = new ResizeObserverController();\r\n\r\n// Registry of the internal observers.\r\nconst observers = new WeakMap();\r\n\r\n/**\r\n * ResizeObservers' \"Proxy\" class which is meant to hide private properties and\r\n * methods from public instances.\r\n *\r\n * Additionally it implements \"idleTimeout\" and \"continuousUpdates\" static property\r\n * accessors to give control over the behavior of the ResizeObserverController\r\n * instance. Changes made to these properties affect all future and existing\r\n * observers.\r\n */\r\nclass ResizeObserver {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {Function} callback - Callback that will be invoked when dimensions\r\n     *      of one of the observed elements have been changed.\r\n     */\r\n    constructor(callback) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        const observer = new _ResizeObserver(callback, controller, this);\r\n\r\n        // Register an internal observer.\r\n        observers.set(this, observer);\r\n    }\r\n\r\n    /**\r\n     * Extracts controllers' idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    static get idleTimeout() {\r\n        return controller.idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    static set idleTimeout(value) {\r\n        if (typeof value !== 'number') {\r\n            throw new TypeError('type of \"idleTimeout\" value must be number.');\r\n        }\r\n\r\n        if (typeof value < 0) {\r\n            throw new TypeError('\"idleTimeout\" value must be greater than 0.');\r\n        }\r\n\r\n        controller.idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Tells whether continuous updates are enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    static get continuousUpdates() {\r\n        return controller.continuousUpdates;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables continuous updates.\r\n     *\r\n     * @param {Boolean} value - Whether to enable or disable continuous updates.\r\n     */\r\n    static set continuousUpdates(value) {\r\n        if (typeof value !== 'boolean') {\r\n            throw new TypeError('type of \"continuousUpdates\" value must be boolean.');\r\n        }\r\n\r\n        controller.continuousUpdates = value;\r\n    }\r\n}\r\n\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(method => {\r\n    ResizeObserver.prototype[method] = function () {\r\n        return observers.get(this)[method](...arguments);\r\n    };\r\n});\r\n\r\nexport default ResizeObserver;\r\n","import ResizeObserverPolyfill from './src/ResizeObserver';\r\n\r\nlet ResizeObserver = ResizeObserverPolyfill;\r\n\r\n// Export existing implementation if it's available.\r\nif (typeof window.ResizeObserver === 'function') {\r\n    ResizeObserver = window.ResizeObserver;\r\n}\r\n\r\nexport default ResizeObserver;\r\n"],"names":["debounce","callback","delay","timeoutID","args","setTimeout","apply","getStyles","target","window","getComputedStyle","pixelsToNumber","value","parseFloat","getBordersSize","styles","positions","reduce","size","pos","getPaddings","boxKeys","paddings","key","createContentRect","width","height","top","left","getSVGContentRect","bbox","getBBox","getDocElementRect","document","documentElement","getHTMLElementContentRect","clientWidth","clientHeight","emptyRect","horizPad","right","vertPad","bottom","boxSizing","Math","round","vertScrollbar","horizScrollbar","abs","isSVGElement","SVGElement","isDocumentElement","getContentRect","defineProperties","props","descr","descriptor","configurable","writable","enumerable","Object","keys","defineProperty","hasNativeCollections","WeakMap","Map","getIndex","arr","result","some","entry","index","matches","__entries__","get","this","set","push","delete","entries","splice","has","clear","length","slice","map","values","forEach","ctx","call","performance","now","Date","requestAnimationFrame","mutationsSupported","MutationObserver","ResizeObserverController","idleTimeout","continuousUpdates","_idleTimeout","_isCycleContinuous","_cycleStartTime","_isCycleActive","_isUpdateScheduled","_listenersEnabled","_mutationsObserver","_observers","runUpdates","bind","_onMutation","_resolveScheduled","_continuousCycleHandler","connect","observer","isConnected","_addListeners","disconnect","observers","indexOf","_removeListeners","_updateObservers","hasChanges","gatherActive","hasActive","broadcastActive","scheduleUpdate","_hasRemainingTime","_endUpdates","timePassed","addEventListener","observe","removeEventListener","attrsChanged","type","useContinuous","ResizeObservation","_contentRect","broadcastWidth","broadcastHeight","broadcastRect","rect","isActive","ResizeObserverEntry","rectData","rectInterface","ClientRect","prototype","contentRect","create","ResizeObserver","controller","publicObserver","TypeError","_callback","_targets","_activeTargets","_controller","_publicObserver","arguments","Element","targets","observation","unobserve","clearActive","activeTargets","_ResizeObserver","method","ResizeObserverPolyfill"],"mappings":"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"}