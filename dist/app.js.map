{"version":3,"file":"app.js","sources":["../node_modules/resize-observer-polyfill/src/utils/geometry.js","../src/app.js","../node_modules/resize-observer-polyfill/src/shims/es6-collections.js","../node_modules/resize-observer-polyfill/src/utils/isBrowser.js","../node_modules/resize-observer-polyfill/src/shims/global.js","../node_modules/resize-observer-polyfill/src/shims/requestAnimationFrame.js","../node_modules/resize-observer-polyfill/src/utils/throttle.js","../node_modules/resize-observer-polyfill/src/ResizeObserverController.js","../node_modules/resize-observer-polyfill/src/utils/defineConfigurable.js","../node_modules/resize-observer-polyfill/src/utils/getWindowOf.js","../node_modules/resize-observer-polyfill/src/ResizeObservation.js","../node_modules/resize-observer-polyfill/src/ResizeObserverEntry.js","../node_modules/resize-observer-polyfill/src/ResizeObserverSPI.js","../node_modules/resize-observer-polyfill/src/ResizeObserver.js","../node_modules/randomcolor/randomColor.js"],"sourcesContent":["import defineConfigurable from './defineConfigurable.js';\r\nimport getWindowOf from './getWindowOf.js';\r\nimport isBrowser from './isBrowser.js';\r\n\r\n// Placeholder of an empty content rectangle.\r\nconst emptyRect = createRectInit(0, 0, 0, 0);\r\n\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles, ...positions) {\r\n    return positions.reduce((size, position) => {\r\n        const value = styles['border-' + position + '-width'];\r\n\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    const positions = ['top', 'right', 'bottom', 'left'];\r\n    const paddings = {};\r\n\r\n    for (const position of positions) {\r\n        const value = styles['padding-' + position];\r\n\r\n        paddings[position] = toFloat(value);\r\n    }\r\n\r\n    return paddings;\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    const bbox = target.getBBox();\r\n\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    const {clientWidth, clientHeight} = target;\r\n\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n\r\n    const styles = getWindowOf(target).getComputedStyle(target);\r\n    const paddings = getPaddings(styles);\r\n    const horizPad = paddings.left + paddings.right;\r\n    const vertPad = paddings.top + paddings.bottom;\r\n\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    let width = toFloat(styles.width),\r\n        height = toFloat(styles.height);\r\n\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        const vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        const horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nconst isSVGGraphicsElement = (() => {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return target => target instanceof getWindowOf(target).SVGGraphicsElement;\r\n    }\r\n\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return target => (\r\n        target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'\r\n    );\r\n})();\r\n\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nexport function getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n\r\n    return getHTMLElementContentRect(target);\r\n}\r\n\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nexport function createReadOnlyRect({x, y, width, height}) {\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    const Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    const rect = Object.create(Constr.prototype);\r\n\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x, y, width, height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n\r\n    return rect;\r\n}\r\n\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nexport function createRectInit(x, y, width, height) {\r\n    return {x, y, width, height};\r\n}\r\n","// We need to use a polyfill itself here,\r\n// not its' possible native implementation.\r\nimport ResizeObserver from 'resize-observer-polyfill/src/ResizeObserver.js';\r\nimport randomColor from 'randomcolor';\r\n\r\nconst hues = [\r\n    'red',\r\n    'pink',\r\n    'blue',\r\n    'orange',\r\n    'purple',\r\n    'monochrome'\r\n];\r\n\r\nlet colorData = {\r\n    luminosity: 'light',\r\n    hue: hues[getRandomInt(0, 5)]\r\n};\r\n\r\nconst observer = new ResizeObserver(entries => {\r\n    for (const entry of entries) {\r\n        const rect = entry.contentRect;\r\n        const dimensionsStr = `${rect.width.toFixed(2)} x ${rect.height.toFixed(2)}`;\r\n\r\n        entry.target.firstElementChild.textContent = dimensionsStr;\r\n    }\r\n});\r\n\r\nlet index = 0;\r\nlet queue = [];\r\n\r\nfunction getRandomInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nfunction updateColorData() {\r\n    colorData.hue = hues[getRandomInt(0, 5)];\r\n}\r\n\r\nfunction generateColor() {\r\n    return randomColor(colorData);\r\n}\r\n\r\nfunction toArray(collection) {\r\n    return Array.prototype.slice.call(collection);\r\n}\r\n\r\nfunction generateElements(container, levels, items = 4) {\r\n    let index = items;\r\n\r\n    levels--;\r\n\r\n    while (index--) {\r\n        let className = 'block';\r\n        const block = document.createElement('div');\r\n\r\n        if (levels) {\r\n            className += ' parent';\r\n\r\n            generateElements(block, levels, items);\r\n        } else {\r\n            className += ' leaf';\r\n\r\n            block.innerHTML = '<span class=\"dimen\"></span>';\r\n            block.style.backgroundColor = generateColor();\r\n        }\r\n\r\n        block.className = className;\r\n\r\n        container.appendChild(block);\r\n    }\r\n}\r\n\r\ngenerateElements(document.getElementById('container'), 2);\r\n\r\nconst blocks = document.querySelectorAll('.block');\r\n\r\nfunction populateQueue() {\r\n    index = 0;\r\n    queue = toArray(blocks);\r\n\r\n    updateColorData();\r\n\r\n    requestAnimationFrame(resolveNextItem);\r\n}\r\n\r\nfunction resolveNextItem() {\r\n    const block = queue.shift();\r\n\r\n    if (!block) {\r\n        setTimeout(populateQueue, 2500)\r\n\r\n        return;\r\n    }\r\n\r\n    if (!index || index === 2) {\r\n        block.style.maxWidth = getRandomInt(30, 50) + '%';\r\n\r\n        if (index === 2) {\r\n            block.style.minHeight = getRandomInt(0, 80) + '%';\r\n        }\r\n    }\r\n\r\n    if (~block.className.indexOf('leaf')) {\r\n        block.style.backgroundColor = generateColor();\r\n    }\r\n\r\n    if (++index === 4) {\r\n        index = 0;\r\n    }\r\n\r\n    requestAnimationFrame(resolveNextItem);\r\n}\r\n\r\n\r\nfor (const leaf of toArray(document.querySelectorAll('.leaf'))) {\r\n    observer.observe(leaf);\r\n}\r\n\r\nsetTimeout(populateQueue, 2000);\r\n","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nconst MapShim = (() => {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        let result = -1;\r\n\r\n        arr.some((entry, index) => {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return class {\r\n        constructor() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        /**\r\n         * @returns {boolean}\r\n         */\r\n        get size() {\r\n            return this.__entries__.length;\r\n        }\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        get(key) {\r\n            const index = getIndex(this.__entries__, key);\r\n            const entry = this.__entries__[index];\r\n\r\n            return entry && entry[1];\r\n        }\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        set(key, value) {\r\n            const index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        delete(key) {\r\n            const entries = this.__entries__;\r\n            const index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        has(key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        }\r\n\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        clear() {\r\n            this.__entries__.splice(0);\r\n        }\r\n\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        forEach(callback, ctx = null) {\r\n            for (const entry of this.__entries__) {\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        }\r\n    };\r\n})();\r\n\r\nexport {MapShim as Map};\r\n","/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nexport default typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\r\n","// Returns global object of a current environment.\r\nexport default (() => {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\r\n","import global from './global.js';\r\n\r\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nexport default (() => {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global);\r\n    }\r\n\r\n    return callback => setTimeout(() => callback(Date.now()), 1000 / 60);\r\n})();\r\n","import requestAnimationFrame from '../shims/requestAnimationFrame.js';\r\n\r\n// Defines minimum timeout before adding a trailing call.\r\nconst trailingTimeout = 2;\r\n\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nexport default function (callback, delay) {\r\n    let leadingCall = false,\r\n        trailingCall = false,\r\n        lastCallTime = 0;\r\n\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n\r\n            callback();\r\n        }\r\n\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame(resolvePending);\r\n    }\r\n\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        const timeStamp = Date.now();\r\n\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        } else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n\r\n        lastCallTime = timeStamp;\r\n    }\r\n\r\n    return proxy;\r\n}\r\n","import isBrowser from './utils/isBrowser.js';\r\nimport throttle from './utils/throttle.js';\r\n\r\n// Minimum delay before invoking the update of observers.\r\nconst REFRESH_DELAY = 20;\r\n\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nconst transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n\r\n// Check if MutationObserver is available.\r\nconst mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nexport default class ResizeObserverController {\r\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\r\n    connected_ = false;\r\n\r\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\r\n    mutationEventsAdded_ = false;\r\n\r\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\r\n    mutationsObserver_ = null;\r\n\r\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\r\n    observers_ = [];\r\n\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    static instance_ = null;\r\n\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    constructor() {\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    addObserver(observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    removeObserver(observer) {\r\n        const observers = this.observers_;\r\n        const index = observers.indexOf(observer);\r\n\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    refresh() {\r\n        const changesDetected = this.updateObservers_();\r\n\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    updateObservers_() {\r\n        // Collect observers that have active observations.\r\n        const activeObservers = this.observers_.filter(observer => {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(observer => observer.broadcastActive());\r\n\r\n        return activeObservers.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    connect_() {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n\r\n        window.addEventListener('resize', this.refresh);\r\n\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        } else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n\r\n        this.connected_ = true;\r\n    }\r\n\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    disconnect_() {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    }\r\n\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    onTransitionEnd_({propertyName = ''}) {\r\n        // Detect whether transition may affect dimensions of an element.\r\n        const isReflowProperty = transitionKeys.some(key => {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    static getInstance() {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n\r\n        return this.instance_;\r\n    }\r\n}\r\n","/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nexport default (target, props) => {\r\n    for (const key of Object.keys(props)) {\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n\r\n    return target;\r\n};\r\n","import global from '../shims/global.js';\r\n\r\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nexport default target => {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    const ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global;\r\n};\r\n","import {createRectInit, getContentRect} from './utils/geometry.js';\r\n\r\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nexport default class ResizeObservation {\r\n    /**\r\n     * Reference to the observed element.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    target;\r\n\r\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\r\n    broadcastWidth = 0;\r\n\r\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\r\n    broadcastHeight = 0;\r\n\r\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\r\n    contentRect_ = createRectInit(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    constructor(target) {\r\n        this.target = target;\r\n    }\r\n\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isActive() {\r\n        const rect = getContentRect(this.target);\r\n\r\n        this.contentRect_ = rect;\r\n\r\n        return (\r\n            rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    broadcastRect() {\r\n        const rect = this.contentRect_;\r\n\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n\r\n        return rect;\r\n    }\r\n}\r\n","import {createReadOnlyRect} from './utils/geometry.js';\r\nimport defineConfigurable from './utils/defineConfigurable.js';\r\n\r\nexport default class ResizeObserverEntry {\r\n    /**\r\n     * Element size of which has changed.\r\n     * Spec: https://wicg.github.io/ResizeObserver/#dom-resizeobserverentry-target\r\n     *\r\n     * @readonly\r\n     * @type {Element}\r\n     */\r\n    target;\r\n\r\n    /**\r\n     * Element's content rectangle.\r\n     * Spec: https://wicg.github.io/ResizeObserver/#dom-resizeobserverentry-contentrect\r\n     *\r\n     * @readonly\r\n     * @type {DOMRectReadOnly}\r\n     */\r\n    contentRect;\r\n\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    constructor(target, rectInit) {\r\n        const contentRect = createReadOnlyRect(rectInit);\r\n\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, {target, contentRect});\r\n    }\r\n}\r\n","import {Map} from './shims/es6-collections.js';\r\nimport ResizeObservation from './ResizeObservation.js';\r\nimport ResizeObserverEntry from './ResizeObserverEntry.js';\r\nimport getWindowOf from './utils/getWindowOf.js';\r\n\r\nexport default class ResizeObserverSPI {\r\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\r\n    activeObservations_ = [];\r\n\r\n    /**\r\n     * Reference to the callback function.\r\n     *\r\n     * @private {ResizeObserverCallback}\r\n     */\r\n    callback_;\r\n\r\n    /**\r\n     * Public ResizeObserver instance which will be passed to the callback\r\n     * function and used as a value of it's \"this\" binding.\r\n     *\r\n     * @private {ResizeObserver}\r\n     */\r\n    callbackCtx_;\r\n\r\n    /**\r\n     * Reference to the associated ResizeObserverController.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    controller_;\r\n\r\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\r\n    observations_ = new Map();\r\n\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    constructor(callback, controller, callbackCtx) {\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    observe(target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const observations = this.observations_;\r\n\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n\r\n        observations.set(target, new ResizeObservation(target));\r\n\r\n        this.controller_.addObserver(this);\r\n\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    }\r\n\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    unobserve(target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        const observations = this.observations_;\r\n\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n\r\n        observations.delete(target);\r\n\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    disconnect() {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    }\r\n\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    gatherActive() {\r\n        this.clearActive();\r\n\r\n        this.observations_.forEach(observation => {\r\n            if (observation.isActive()) {\r\n                this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    broadcastActive() {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n\r\n        const ctx = this.callbackCtx_;\r\n\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        const entries = this.activeObservations_.map(observation => {\r\n            return new ResizeObserverEntry(\r\n                observation.target,\r\n                observation.broadcastRect()\r\n            );\r\n        });\r\n\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    }\r\n\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    clearActive() {\r\n        this.activeObservations_.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    hasActive() {\r\n        return this.activeObservations_.length > 0;\r\n    }\r\n}\r\n","import {Map} from './shims/es6-collections.js';\r\nimport ResizeObserverController from './ResizeObserverController.js';\r\nimport ResizeObserverSPI from './ResizeObserverSPI.js';\r\n\r\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nconst observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new Map();\r\n\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nclass ResizeObserver {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    constructor(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        const controller = ResizeObserverController.getInstance();\r\n        const observer = new ResizeObserverSPI(callback, controller, this);\r\n\r\n        observers.set(this, observer);\r\n    }\r\n}\r\n\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(method => {\r\n    ResizeObserver.prototype[method] = function () {\r\n        return observers.get(this)[method](...arguments);\r\n    };\r\n});\r\n\r\nexport default ResizeObserver;\r\n","// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (typeof exports === 'object') {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        // Since we're generating multiple colors,\n        // incremement the seed. Otherwise we'd just\n        // generate the same color each time...\n        if (seed && options.seed) options.seed += 1;\n\n        colors.push(randomColor(options));\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue (options) {\n\n    var hueRange = getHueRange(options.hue),\n        hue = randomWithin(hueRange);\n\n    // Instead of storing red as two seperate ranges,\n    // we group them, using negative numbers\n    if (hue < 0) {hue = 360 + hue;}\n\n    return hue;\n\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n    }\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [19,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [47,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [63,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [179, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [258, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [283, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  return randomColor;\n}));\n"],"names":["toFloat","value","parseFloat","getBordersSize","styles","positions","reduce","size","position","getHTMLElementContentRect","target","clientWidth","clientHeight","emptyRect","getWindowOf","getComputedStyle","paddings","const","getPaddings","horizPad","left","right","vertPad","top","bottom","width","height","boxSizing","Math","round","document","documentElement","isDocumentElement","vertScrollbar","horizScrollbar","abs","createRectInit","getContentRect","isBrowser","isSVGGraphicsElement","bbox","getBBox","getSVGContentRect","x","y","getRandomInt","min","max","floor","random","generateColor","randomColor","colorData","toArray","collection","Array","prototype","slice","call","generateElements","container","levels","items","index","className","block","createElement","innerHTML","style","backgroundColor","appendChild","populateQueue","blocks","hue","hues","resolveNextItem","queue","shift","maxWidth","minHeight","indexOf","MapShim","getIndex","arr","key","result","some","entry","Map","__entries__","this","length","push","entries","splice","callback","ctx","window","global","self","Function","requestAnimationFrame","bind","setTimeout","Date","now","trailingTimeout","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","delay","resolvePending","leadingCall","trailingCall","timeoutCallback","proxy","timeStamp","lastCallTime","throttle","addObserver","observer","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","filter","gatherActive","hasActive","forEach","broadcastActive","addEventListener","observe","removeEventListener","disconnect","ref","propertyName","getInstance","instance_","props","Object","keys","defineProperty","ownerDocument","defaultView","SVGGraphicsElement","SVGElement","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","rect","broadcastRect","ResizeObserverEntry","rectInit","contentRect","Constr","DOMRectReadOnly","create","createReadOnlyRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","TypeError","callback_","controller_","callbackCtx_","arguments","Element","observations","has","set","unobserve","delete","clearActive","clear","observation","map","WeakMap","ResizeObserver","method","get","root","factory","pickHue","options","randomWithin","colorInput","parseInt","number","colorDictionary","color","hueRange","match","hex","replace","red","substr","green","blue","cMax","delta","saturation","HexToHSB","getHueRange","pickSaturation","luminosity","saturationRange","getColorInfo","getSaturationRange","sMin","sMax","pickBrightness","H","S","bMin","lowerBounds","i","s1","v1","s2","v2","m","getMinimumBrightness","bMax","setFormat","hsv","format","HSVtoHSL","hsl","hslColor","alpha","HSVtoRGB","join","rgbColor","componentToHex","c","toString","rgb","HSVtoHex","colorName","range","seed","rnd","defineColor","name","h","s","v","h_i","f","p","q","t","r","g","b","k","undefined","string","total","Number","MAX_SAFE_INTEGER","charCodeAt","stringToInteger","B","count","totalColors","colors","module","exports","dimensionsStr","toFixed","firstElementChild","textContent","getElementById","querySelectorAll","leaf"],"mappings":"yBAaA,SAASA,EAAQC,UACNC,WAAWD,IAAU,EAUhC,SAASE,EAAeC,wEACbC,EAAUC,gBAAQC,EAAMC,UAGpBD,EAAOP,EAFAI,EAAO,UAAYI,EAAW,YAG7C,GAyCP,SAASC,EAA0BC,OAGxBC,gBAAaC,qBAUfD,IAAgBC,SACVC,MAGLT,EAASU,EAAYJ,GAAQK,iBAAiBL,GAC9CM,EAlDV,SAAqBZ,OAIZ,IAFCY,YADa,MAAO,QAAS,SAAU,wBAGX,CAA7BC,IAAMT,OACDP,EAAQG,EAAO,WAAaI,KAEzBA,GAAYR,EAAQC,UAG1Be,EAwCUE,CAAYd,GACvBe,EAAWH,EAASI,KAAOJ,EAASK,MACpCC,EAAUN,EAASO,IAAMP,EAASQ,OAMpCC,EAAQzB,EAAQI,EAAOqB,OACvBC,EAAS1B,EAAQI,EAAOsB,WAIH,eAArBtB,EAAOuB,YAOHC,KAAKC,MAAMJ,EAAQN,KAAcR,OACxBR,EAAeC,EAAQ,OAAQ,SAAWe,GAGnDS,KAAKC,MAAMH,EAASJ,KAAaV,OACvBT,EAAeC,EAAQ,MAAO,UAAYkB,KA6DhE,SAA2BZ,UAChBA,IAAWI,EAAYJ,GAAQoB,SAASC,gBAtD1CC,CAAkBtB,GAAS,KAKtBuB,EAAgBL,KAAKC,MAAMJ,EAAQN,GAAYR,EAC/CuB,EAAiBN,KAAKC,MAAMH,EAASJ,GAAWV,EAOtB,IAA5BgB,KAAKO,IAAIF,QACAA,GAGoB,IAA7BL,KAAKO,IAAID,QACCA,UAIXE,EAAepB,EAASI,KAAMJ,EAASO,IAAKE,EAAOC,GAyC9D,SAAgBW,EAAe3B,UACtB4B,EAIDC,EAAqB7B,GAnI7B,SAA2BA,OACjB8B,EAAO9B,EAAO+B,iBAEbL,EAAe,EAAG,EAAGI,EAAKf,MAAOe,EAAKd,QAiIlCgB,CAAkBhC,GAGtBD,EAA0BC,GAPtBG,EA4Cf,SAAgBuB,EAAeO,EAAGC,EAAGnB,EAAOC,YAChCiB,IAAGC,QAAGnB,SAAOC,GCxMzB,SAASmB,EAAaC,EAAKC,UAChBnB,KAAKoB,MAAMpB,KAAKqB,UAAYF,EAAMD,EAAM,IAAMA,EAOzD,SAASI,WACEC,EAAYC,GAGvB,SAASC,EAAQC,UACNC,MAAMC,UAAUC,MAAMC,KAAKJ,GAGtC,SAASK,EAAiBC,EAAWC,EAAQC,kBAAQ,OAC7CC,EAAQD,UAILC,KAAS,KACRC,EAAY,QACVC,EAAQnC,SAASoC,cAAc,OAEjCL,MACa,YAEII,EAAOJ,EAAQC,QAEnB,UAEPK,UAAY,gCACZC,MAAMC,gBAAkBnB,OAG5Bc,UAAYA,IAERM,YAAYL,IAQ9B,SAASM,MACG,IACAlB,EAAQmB,KA3CNC,IAAMC,EAAK7B,EAAa,EAAG,0BA+Cf8B,GAG1B,SAASA,QACCV,EAAQW,EAAMC,QAEfZ,GAMAF,GAAmB,IAAVA,MACJK,MAAMU,SAAWjC,EAAa,GAAI,IAAM,IAEhC,IAAVkB,MACMK,MAAMW,UAAYlC,EAAa,EAAG,IAAM,OAIjDoB,EAAMD,UAAUgB,QAAQ,YACnBZ,MAAMC,gBAAkBnB,KAGlB,KAAVa,MACM,yBAGUY,eArBPJ,EAAe,MCnFlCtD,IAAMgE,EAAU,oBAYHC,EAASC,EAAKC,OACfC,GAAU,WAEVC,cAAMC,EAAOxB,UACTwB,EAAM,KAAOH,MACJrB,GAEF,KAMRsB,QAxBQ,oBAARG,IACAA,iCA4BEC,6CAMLlF,2BACOmF,KAAKD,EAAYE,iCAOxBP,OACMrB,EAAQmB,EAASQ,KAAKD,EAAaL,GACnCG,EAAQG,KAAKD,EAAY1B,UAExBwB,GAASA,EAAM,6BAQtBH,EAAKnF,OACC8D,EAAQmB,EAASQ,KAAKD,EAAaL,IAEpCrB,OACI0B,EAAY1B,GAAO,GAAK9D,OAExBwF,EAAYG,MAAMR,EAAKnF,iCAQ7BmF,OACGS,EAAUH,KAAKD,EACf1B,EAAQmB,EAASW,EAAST,IAE3BrB,KACO+B,OAAO/B,EAAO,6BAQ1BqB,YACUF,EAASQ,KAAKD,EAAaL,sCAOhCK,EAAYK,OAAO,iCAQpBC,EAAUC,kBAAM,UACf,eAAoBP,kBAAa,CAAjCxE,IAAMsE,SACE7B,KAAKsC,EAAKT,EAAM,GAAIA,EAAM,kDArGnC,KCJiB,oBAAXU,QAA8C,oBAAbnE,UAA4BmE,OAAOnE,WAAaA,WCD7E,oBAAXoE,QAA0BA,OAAOtE,OAASA,KAC1CsE,OAGS,oBAATC,MAAwBA,KAAKvE,OAASA,KACtCuE,KAGW,oBAAXF,QAA0BA,OAAOrE,OAASA,KAC1CqE,OAIJG,SAAS,cAATA,KCN8B,mBAA1BC,sBAIAA,sBAAsBC,KAAKJ,YAG/BH,UAAYQ,6BAAiBR,EAASS,KAAKC,QAAQ,IAAO,KCb/DC,EAAkB,ECKlBC,GAAkB,MAAO,QAAS,SAAU,OAAQ,QAAS,SAAU,OAAQ,UAG/EC,EAAwD,oBAArBC,iBAKpBC,kBAMjBC,GAAa,OAObC,GAAuB,OAOvBC,EAAqB,UAOrBC,UAeSC,EAAmBzB,KAAKyB,EAAiBb,KAAKZ,WAC9C0B,QD9CE,SAAUrB,EAAUsB,YAWtBC,IACDC,OACc,OAKdC,gBAYCC,MACiBH,YAQjBI,QACCC,EAAYnB,KAAKC,SAEnBc,EAAa,IAETI,EAAYC,EAAelB,YAQhB,UAED,KACC,aAEJe,EAAiBJ,KAGjBM,MA3DfJ,GAAc,EACdC,GAAe,EACfI,EAAe,SA4DZF,ECjBYG,CAASnC,KAAK0B,QAAQd,KAAKZ,MAvD5B,KAgElBoC,iCAAYC,IACFrC,KAAKwB,EAAWlC,QAAQ+C,SACrBb,EAAWtB,KAAKmC,GAIpBrC,KAAKqB,QACDiB,KAUbC,oCAAeF,OACLG,EAAYxC,KAAKwB,EACjBnD,EAAQmE,EAAUlD,QAAQ+C,IAG3BhE,KACS+B,OAAO/B,EAAO,IAIvBmE,EAAUvC,QAAUD,KAAKqB,QACrBoB,KAUbf,+BAC4B1B,KAAK0C,UAKpBhB,WAYbgB,6BAEUC,EAAkB3C,KAAKwB,EAAWoB,gBAAOP,UACpCA,EAASQ,eAAgBR,EAASS,uBAQ7BC,iBAAQV,UAAYA,EAASW,oBAEtCL,EAAgB1C,OAAS,GASpCqC,yBAGS1F,IAAaoD,KAAKqB,aAOd4B,iBAAiB,gBAAiBjD,KAAKyB,UAEzCwB,iBAAiB,SAAUjD,KAAK0B,SAEnCR,QACKK,EAAqB,IAAIJ,iBAAiBnB,KAAK0B,cAE/CH,EAAmB2B,QAAQ9G,sBAChB,aACD,iBACI,WACN,eAGJ6G,iBAAiB,qBAAsBjD,KAAK0B,cAEhDJ,GAAuB,QAG3BD,GAAa,IAStBoB,yBAGS7F,GAAcoD,KAAKqB,aAIf8B,oBAAoB,gBAAiBnD,KAAKyB,UAC5C0B,oBAAoB,SAAUnD,KAAK0B,SAEtC1B,KAAKuB,QACAA,EAAmB6B,aAGxBpD,KAAKsB,YACI6B,oBAAoB,qBAAsBnD,KAAK0B,cAGvDH,EAAqB,UACrBD,GAAuB,OACvBD,GAAa,IAUtBI,uBAAiB4B,uCAAgB,IAEJpC,EAAerB,cAAKF,YAC/B4D,EAAahE,QAAQI,WAI1BgC,WASbN,EAAOmC,8BACEvD,KAAKwD,SACDA,EAAY,IAAIpC,GAGlBpB,KAAKwD,KAzLTA,EAAY,KC3CvB,eAAgBxI,EAAQyI,OACf,UAAaC,OAAOC,KAAKF,mBAAQ,CAAjClI,IAAMmE,cACAkE,eAAe5I,EAAQ0E,SACnB+D,EAAM/D,eACD,YACF,gBACI,WAIf1E,cCTIA,UAISA,GAAUA,EAAO6I,eAAiB7I,EAAO6I,cAAcC,aAIrDtD,GTXpBrF,EAAYuB,EAAe,EAAG,EAAG,EAAG,GAmJpCG,EAGgC,oBAAvBkH,4BACA/I,UAAUA,aAAkBI,EAAYJ,GAAQ+I,6BAMpD/I,UACHA,aAAkBI,EAAYJ,GAAQgJ,YACZ,mBAAnBhJ,EAAO+B,SU9JDkH,WAkCLjJ,QArBZkJ,eAAiB,OAOjBC,gBAAkB,OAOlBC,EAAe1H,EAAe,EAAG,EAAG,EAAG,QAQ9B1B,OAASA,GASlBqJ,oCACUC,EAAO3H,EAAeqD,KAAKhF,oBAE5BoJ,EAAeE,EAGhBA,EAAKvI,QAAUiE,KAAKkE,gBACpBI,EAAKtI,SAAWgE,KAAKmE,iBAU7BI,yCACUD,EAAOtE,KAAKoE,cAEbF,eAAiBI,EAAKvI,WACtBoI,gBAAkBG,EAAKtI,OAErBsI,GCtEf,IAAqBE,WAyBLxJ,EAAQyJ,OACVC,EX8Kd,SAAmCrB,OAACpG,MAAGC,MAAGnB,UAAOC,WAEvC2I,EAAoC,oBAApBC,gBAAkCA,gBAAkBlB,OACpEY,EAAOZ,OAAOmB,OAAOF,EAAO7G,oBAGfwG,SACZpH,QAAGnB,SAAOC,MACRkB,QACED,EAAIlB,SACHC,EAASkB,OACXD,IAGHqH,EW5LiBQ,CAAmBL,KAQpBzE,aAAOhF,cAAQ0J,KChCrBK,WAgDL1E,EAAU2E,EAAYC,WAzClCC,UA6BAC,EAAgB,IAAIrF,EAaQ,mBAAbO,QACD,IAAI+E,UAAU,gEAGnBC,EAAYhF,OACZiF,EAAcN,OACdO,EAAeN,GASxB/B,6BAAQlI,OACCwK,UAAUvF,aACL,IAAImF,UAAU,+CAID,oBAAZK,SAA6BA,mBAAmB/B,aAIrD1I,aAAkBI,EAAYJ,GAAQyK,eAClC,IAAIL,UAAU,6CAGlBM,EAAe1F,KAAKmF,EAGtBO,EAAaC,IAAI3K,OAIR4K,IAAI5K,EAAQ,IAAIiJ,EAAkBjJ,SAE1CsK,EAAYlD,YAAYpC,WAGxBsF,EAAY5D,aASrBmE,+BAAU7K,OACDwK,UAAUvF,aACL,IAAImF,UAAU,+CAID,oBAAZK,SAA6BA,mBAAmB/B,aAIrD1I,aAAkBI,EAAYJ,GAAQyK,eAClC,IAAIL,UAAU,6CAGlBM,EAAe1F,KAAKmF,EAGrBO,EAAaC,IAAI3K,OAIT8K,OAAO9K,GAEf0K,EAAa7K,WACTyK,EAAY/C,eAAevC,SASxCoD,uCACS2C,mBACAZ,EAAca,aACdV,EAAY/C,eAAevC,OASpC6C,oDACSkD,mBAEAZ,EAAcpC,iBAAQkD,GACnBA,EAAY5B,cACPa,EAAoBhF,KAAK+F,MAW1CjD,0CAEShD,KAAK8C,iBAIJxC,EAAMN,KAAKuF,EAGXpF,EAAUH,KAAKkF,EAAoBgB,aAAID,UAClC,IAAIzB,EACPyB,EAAYjL,OACZiL,EAAY1B,wBAIfc,EAAUrH,KAAKsC,EAAKH,EAASG,QAC7ByF,gBAQTA,wCACSb,EAAoB9E,OAAO,IAQpC0C,wCACW9C,KAAKkF,EAAoBjF,OAAS,GCjMjD1E,IAAMiH,EAA+B,oBAAZ2D,QAA0B,IAAIA,QAAY,IAAIrG,EAMjEsG,WAOU/F,QACFL,gBAAgBoG,SACZ,IAAIhB,UAAU,0CAEnBI,UAAUvF,aACL,IAAImF,UAAU,gDAGlBJ,EAAa5D,EAAyBmC,cACtClB,EAAW,IAAI0C,EAAkB1E,EAAU2E,EAAYhF,QAEnD4F,IAAI5F,KAAMqC,KAMxB,UACA,YACA,cACFU,iBAAQsD,KACSvI,UAAUuI,GAAU,oBACxB7D,EAAU8D,IAAItG,OAAMqG,SAAQhD,EAAGmC,0MCvC9C,SAAWe,EAAMC,OAIT/I,EAmBA,oBAuEGgJ,EAASC,OAGZ3H,EAAM4H,WAkIUC,MAEgB,iBAAzBC,SAASD,GAA0B,KAExCE,EAASD,SAASD,MAElBE,EAAS,KAAOA,EAAS,SACnBA,EAAQA,MAKM,iBAAfF,KAELG,EAAgBH,GAAa,KAC3BI,EAAQD,EAAgBH,MACxBI,EAAMC,gBAAkBD,EAAMC,cAC7B,GAAIL,EAAWM,MAAM,kCAAmC,KACzDnI,WAkKSoI,KAEI,OADfA,EAAIC,QAAQ,KAAM,KACdnH,OAAekH,EAAIC,QAAQ,OAAQ,QAAUD,MAEnDE,EAAMR,SAASM,EAAIG,OAAO,EAAG,GAAI,IAAM,IACrCC,EAAQV,SAASM,EAAIG,OAAO,EAAG,GAAI,IAAM,IACzCE,EAAOX,SAASM,EAAIG,OAAO,EAAG,GAAI,IAAM,IAE1CG,EAAOvL,KAAKmB,IAAIgK,EAAKE,EAAOC,GAC1BE,EAAQD,EAAOvL,KAAKkB,IAAIiK,EAAKE,EAAOC,GACpCG,EAAaF,EAAQC,EAAQD,EAAQ,SAEnCA,QACDJ,UAAsBE,EAAQC,GAAQE,EAAS,EAAjC,IAAuC,EAAGC,EAAYF,QACpEF,SAAgB,KAAQC,EAAOH,GAAOK,EAAS,IAAM,EAAGC,EAAYF,QACpED,SAAe,KAAQH,EAAME,GAASG,EAAS,IAAM,EAAGC,EAAYF,IAjL7DG,CAAShB,GAAY,UACtB7H,EAAKA,UAIV,EAAE,KA1JK8I,CAAYnB,EAAQ3H,aAK/BA,EAAM,MAAU,IAAMA,GAEnBA,WAIA+I,EAAgB/I,EAAK2H,MAER,eAAhBA,EAAQ3H,WACH,KAGkB,WAAvB2H,EAAQqB,kBACHpB,GAAc,EAAE,UAGrBqB,WAyIuBjJ,UACpBkJ,EAAalJ,GAAKiJ,gBA1IHE,CAAmBnJ,GAErCoJ,EAAOH,EAAgB,GACvBI,EAAOJ,EAAgB,UAEnBtB,EAAQqB,gBAET,WACI,aAGJ,SACIK,EAAO,aAGX,UACI,UAIJzB,GAAcwB,EAAMC,aAIpBC,EAAgBC,EAAGC,EAAG7B,OAEzB8B,WA2DwBF,EAAGC,OAI1B,IAFDE,EAAcR,EAAaK,GAAGG,YAEzBC,EAAI,EAAGA,EAAID,EAAYxI,OAAS,EAAGyI,IAAK,KAE3CC,EAAKF,EAAYC,GAAG,GACpBE,EAAKH,EAAYC,GAAG,GAEpBG,EAAKJ,EAAYC,EAAE,GAAG,GACtBI,EAAKL,EAAYC,EAAE,GAAG,MAEtBH,GAAKI,GAAMJ,GAAKM,EAAI,KAEjBE,GAAKD,EAAKF,IAAKC,EAAKF,UAGjBI,EAAER,GAFDK,EAAKG,EAAEJ,WAOb,EAjFIK,CAAqBV,EAAGC,GAC/BU,EAAO,WAEHvC,EAAQqB,gBAET,SACIS,EAAO,aAGX,WACKS,EAAOT,GAAM,YAGlB,WACI,IACA,WAIJ7B,GAAc6B,EAAMS,aAGpBC,EAAWC,EAAKzC,UAEfA,EAAQ0C,YAET,kBACID,MAEJ,kBACIE,EAASF,OAEb,UACCG,EAAMD,EAASF,SACZ,OAAOG,EAAI,GAAG,KAAKA,EAAI,GAAG,MAAMA,EAAI,GAAG,SAE3C,WACCC,EAAWF,EAASF,GACpBK,EAAQ9C,EAAQ8C,OAAStN,KAAKqB,eAC3B,QAAQgM,EAAS,GAAG,KAAKA,EAAS,GAAG,MAAMA,EAAS,GAAG,MAAQC,EAAQ,QAE3E,kBACIC,EAASN,OAEb,YAEI,OADGM,EAASN,GACCO,KAAK,MAAQ,QAE9B,WACCC,EAAWF,EAASN,GACpBK,EAAQ9C,EAAQ8C,OAAStN,KAAKqB,eAC3B,QAAUoM,EAASD,KAAK,MAAQ,KAAOF,EAAQ,4BA8FzCL,YAIRS,EAAeC,OAChB1C,EAAM0C,EAAEC,SAAS,WACA,GAAd3C,EAAIlH,OAAc,IAAMkH,EAAMA,MAJrC4C,EAAMN,EAASN,SAOT,IAAMS,EAAeG,EAAI,IAAMH,EAAeG,EAAI,IAAMH,EAAeG,EAAI,IApG1EC,CAASb,aA6DblB,EAAclJ,GAGjBA,GAAO,KAAOA,GAAO,SACjB,SAGH,IAAIkL,KAAalD,EAAiB,KAChCC,EAAQD,EAAgBkD,MACxBjD,EAAMC,UACNlI,GAAOiI,EAAMC,SAAS,IACtBlI,GAAOiI,EAAMC,SAAS,UAChBF,EAAgBkD,GAE3B,MAAO,2BAGFtD,EAAcuD,MACR,OAATC,SACKjO,KAAKoB,MAAM4M,EAAM,GAAKhO,KAAKqB,UAAU2M,EAAM,GAAK,EAAIA,EAAM,SAG7D7M,EAAM6M,EAAM,IAAM,EAClB9M,EAAM8M,EAAM,IAAM,EAElBE,MADW,KAAPD,EAAc,OAAS,QACd,cACVjO,KAAKoB,MAAMF,EAAMgN,GAAO/M,EAAMD,aAmBhCiN,EAAaC,EAAMrD,EAAUwB,OAEhCN,EAAOM,EAAY,GAAG,GACtBL,EAAOK,EAAYA,EAAYxI,OAAS,GAAG,GAE3CuI,EAAOC,EAAYA,EAAYxI,OAAS,GAAG,GAC3CgJ,EAAOR,EAAY,GAAG,KAEV6B,aACJrD,cACGwB,mBACKN,EAAMC,oBACNI,EAAMS,aAyDnBQ,EAAUN,OAIboB,EAAIpB,EAAI,GACF,IAANoB,MAAc,GACR,MAANA,MAAgB,QAGd,QACFC,EAAIrB,EAAI,GAAG,IACXsB,EAAItB,EAAI,GAAG,IAEXuB,EAAMxO,KAAKoB,MAAQ,EAAFiN,GACnBI,EAAQ,EAAJJ,EAAQG,EACZE,EAAIH,GAAK,EAAID,GACbK,EAAIJ,GAAK,EAAIE,EAAEH,GACfM,EAAIL,GAAK,GAAK,EAAIE,GAAGH,GACrBO,EAAI,IACJC,EAAI,IACJC,EAAI,WAECP,QACA,IAAOD,EAAGO,EAAIF,EAAGG,EAAIL,EAAI,WACzB,IAAOC,EAAGG,EAAIP,EAAGQ,EAAIL,EAAI,WACzB,IAAOA,EAAGI,EAAIP,EAAGQ,EAAIH,EAAI,WACzB,IAAOF,EAAGI,EAAIH,EAAGI,EAAIR,EAAI,WACzB,IAAOK,EAAGE,EAAIJ,EAAGK,EAAIR,EAAI,WACzB,IAAOA,EAAGO,EAAIJ,EAAGK,EAAIJ,SAGd3O,KAAKoB,MAAQ,IAAFyN,GAAQ7O,KAAKoB,MAAQ,IAAF0N,GAAQ9O,KAAKoB,MAAQ,IAAF2N,aAuBxD5B,EAAUF,OACboB,EAAIpB,EAAI,GACVqB,EAAIrB,EAAI,GAAG,IACXsB,EAAItB,EAAI,GAAG,IACX+B,GAAK,EAAEV,GAAGC,SAGVF,EACArO,KAAKC,MAAMqO,EAAEC,GAAKS,EAAE,EAAIA,EAAI,EAAEA,GAAK,KAAS,IAC5CA,EAAE,EAAI,SAzZNf,EAAO,KAGPpD,OAsSA,aACA,OACE,EAAE,IAAI,IAAI,OAIZ,QACE,GAAG,MACH,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,QAIvE,UACC,GAAG,MACF,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,QAIvD,UACC,GAAG,MACF,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,QAI/D,SACC,GAAG,OACF,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,QAI/D,QACC,IAAK,OACJ,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,QAIvE,UACC,IAAK,OACJ,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,QAIvE,QACC,IAAK,OACJ,GAAG,MAAM,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,UA7UvDtJ,EAAc,SAAUiJ,WAMLyE,OAJXzE,OAIEyD,MAAuC,OAAjBzD,EAAQyD,MAAiBzD,EAAQyD,OAAStD,SAASH,EAAQyD,KAAM,MAC1FzD,EAAQyD,UAGV,GAA4B,iBAAjBzD,EAAQyD,gBA2YFiB,OAEnB,IADDC,EAAQ,EACH3C,EAAI,EAAGA,IAAM0C,EAAOnL,UACvBoL,GAASC,OAAOC,kBADe7C,OAE1B0C,EAAOI,WAAW9C,UAEtB2C,EAhZEI,CAAgB/E,EAAQyD,UAG1B,CAAA,QAAqBgB,IAAjBzE,EAAQyD,MAAuC,OAAjBzD,EAAQyD,WACzC,IAAI/E,UAAU,iDAIb,SAGLkD,EAAEC,EAAEmD,KAGc,OAAlBhF,EAAQiF,YAAoCR,IAAlBzE,EAAQiF,MAAqB,KAErDC,EAAclF,EAAQiF,MACtBE,WAEIF,MAAQ,KAETC,EAAcC,EAAO5L,QAKtBkK,GAAQzD,EAAQyD,OAAMzD,EAAQyD,MAAQ,KAEnCjK,KAAKzC,EAAYiJ,aAGlBiF,MAAQC,EAETC,WAILpF,EAAQC,KAGRoB,EAAeQ,EAAG5B,KAGlB2B,EAAeC,EAAGC,EAAG7B,GAGlBwC,GAAWZ,EAAEC,EAAEmD,GAAIhF,WAqWrBjJ,EA5ba+I,GAGgBsF,GAAUA,EAAOC,YACvCD,UAAiBrO,iBAIPA,EAZ1B,KbEMuB,kBACF,MACA,OACA,OACA,SACA,SACA,eAGAtB,cACY,YACPsB,EAAK7B,EAAa,EAAG,KAGxBkF,EAAW,IAAI+D,WAAejG,OAC3B,UAAeA,kBAAS,CAAxB5E,IAAMsE,OACDyE,EAAOzE,EAAM6E,YACbsH,EAAmB1H,EAAKvI,MAAMkQ,QAAQ,SAAQ3H,EAAKtI,OAAOiQ,QAAQ,KAElEjR,OAAOkR,kBAAkBC,YAAcH,KAIjD3N,EAAQ,EACRa,KA4CJjB,EAAiB7B,SAASgQ,eAAe,aAAc,GA0CvD,IAAK,IAxCCtN,EAAS1C,SAASiQ,iBAAiB,gBAwCtB1O,EAAQvB,SAASiQ,iBAAiB,0BAAW,CAA3D9Q,IAAM+Q,SACEpJ,QAAQoJ,GAGrBzL,WAAWhC,EAAe"}